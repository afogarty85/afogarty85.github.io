<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Andrew Fogarty" />


<title>Text Classification: CNN</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Text Classification: CNN</h1>
<h4 class="author">Andrew Fogarty</h4>
<h4 class="date">7/14/2020</h4>


<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#convolutional-neural-networks"><span class="toc-section-number">2</span> Convolutional Neural Networks</a></li>
<li><a href="#cnns-using-glove-embeddings"><span class="toc-section-number">3</span> CNNs using GloVe Embeddings</a></li>
<li><a href="#cnn-inference"><span class="toc-section-number">4</span> CNN: Inference</a></li>
<li><a href="#cnn-hyperband-and-asha-hyperparameter-search-with-optuna"><span class="toc-section-number">5</span> CNN: Hyperband and ASHA Hyperparameter Search with Optuna</a></li>
<li><a href="#sources"><span class="toc-section-number">6</span> Sources</a></li>
</ul>
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># load python</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">library</span>(reticulate)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">use_condaenv</span>(<span class="st">&quot;my_ml&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># load packages</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="im">import</span> torch</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="im">import</span> torch.nn <span class="im">as</span> nn</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="im">import</span> torch.optim <span class="im">as</span> optim</a>
<a class="sourceLine" id="cb2-9" title="9"><span class="im">from</span> torchvision <span class="im">import</span> datasets, transforms</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="im">from</span> torch.utils.data <span class="im">import</span> TensorDataset, random_split, DataLoader, RandomSampler, SequentialSampler</a>
<a class="sourceLine" id="cb2-11" title="11"><span class="im">import</span> time, datetime, re, random, string</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score, f1_score, precision_score, recall_score</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="im">from</span> collections <span class="im">import</span> Counter</a>
<a class="sourceLine" id="cb2-14" title="14"><span class="im">from</span> transformers <span class="im">import</span> get_linear_schedule_with_warmup</a>
<a class="sourceLine" id="cb2-15" title="15"><span class="im">from</span> itertools <span class="im">import</span> repeat</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="im">import</span> optuna</a>
<a class="sourceLine" id="cb2-17" title="17"><span class="im">from</span> optuna.pruners <span class="im">import</span> SuccessiveHalvingPruner</a>
<a class="sourceLine" id="cb2-18" title="18"><span class="im">from</span> optuna.samplers <span class="im">import</span> TPESampler</a>
<a class="sourceLine" id="cb2-19" title="19"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb2-20" title="20"><span class="im">import</span> seaborn <span class="im">as</span> sns</a>
<a class="sourceLine" id="cb2-21" title="21"><span class="im">from</span> torch.cuda.amp <span class="im">import</span> autocast, GradScaler</a>
<a class="sourceLine" id="cb2-22" title="22"><span class="im">from</span> transformers <span class="im">import</span> get_linear_schedule_with_warmup, AdamW</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">SEED <span class="op">=</span> <span class="dv">15</span></a>
<a class="sourceLine" id="cb2-25" title="25">random.seed(SEED)</a>
<a class="sourceLine" id="cb2-26" title="26">np.random.seed(SEED)</a>
<a class="sourceLine" id="cb2-27" title="27">torch.manual_seed(SEED)</a></code></pre></div>
<pre><code>## &lt;torch._C.Generator object at 0x000000001F94E050&gt;</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">torch.backends.cudnn.deterministic <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb4-2" title="2">torch.cuda.amp.autocast(enabled<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># tell pytorch to use cuda</span></a></code></pre></div>
<pre><code>## &lt;torch.cuda.amp.autocast_mode.autocast object at 0x0000000033B55788&gt;</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">device <span class="op">=</span> torch.device(<span class="st">&quot;cuda&quot;</span>)</a></code></pre></div>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>Text or sequence classification aims to label a sentence or document based on its content. In this post, we use Convolutional Neural Networks to classify a novel data set that I created based on insurgent propaganda messages. This guide stands in contrast to other walk-throughs on the model in that it: (1) offers a full treatment of data preparation and PyTorch, (2) uses GloVe embeddings correctly by taking into account unknown or padding tokens by generating unique vectors for them, and (3) specifically tells the <code>embedding</code> layer which look-up index is the padding token.</p>
</div>
<div id="convolutional-neural-networks" class="section level1">
<h1><span class="header-section-number">2</span> Convolutional Neural Networks</h1>
<p>In this section, we run a CNN with GloVe embeddings after addressing some of the high points about CNNs. Convolutional layers aim to find spatial patterns, predominantly in images, through the use of <em>kernels</em>. Kernels can be thought of as small windows that slide across the pixels of an image - calculating the respective weight by multiplying the pixel values with the kernel weight. These values are then summed to get a filtered pixel value which in turn are representative of local features.</p>
<p>In Natural Language Processing, text is one-dimensional but we often represent each word (or character) with an embedding vector, thereby giving our text a two-dimensional representation. The convolutional kernel slides over the embeddings (features) of multiple words rather than pixels. Instead of three input channels like Red Green Blue for images, text processing has just 1 (akin to gray scale) because a single sentence/document will be associated with a single list of embeddings. To slide a kernel over sequences of word embeddings, the sliding window needs to be allowed to look at multiple word embeddings in a sequence. Instead of a square, kernels take on shapes associated with the number of words (<span class="math inline">\(n\)</span>) to look at in a sequence and the length of the embedding sequence (<span class="math inline">\(m\)</span>). This <span class="math inline">\(n\times m\)</span> kernel tells us how many word embeddings it will view at once, like n-grams, while also the length of the word embedding that it will take it account, say 200 or 300 for GLoVe or 768 for BERT.</p>
<p>CNNs tend to include multiple kernel heights, typically 3, each representing a different n-gram range. As a CNN trains, kernel weights are learned for words and surrounding words in a sequential window, yielding local features. CNNs then use max-pooling which aims to retain only the most important (highest value) local feature while discarding less important features.</p>
</div>
<div id="cnns-using-glove-embeddings" class="section level1">
<h1><span class="header-section-number">3</span> CNNs using GloVe Embeddings</h1>
<p>GloVe is a common set of embeddings used by practitioners and academics in text analysis containing features for 400,000 words. Embeddings capture the similarities between words (e.g., they have high cosine similarities) and are the basis of NLP. Word embedding methods represent words as continuous vectors in a low dimensional space which capture lexical and semantic properties of words. Embeddings can be obtained from the internal representations from neural network models of text or by low rank approximation of co-occurrence statistics.</p>
<p>In this section, I will describe how to set up, correctly, a CNN in PyTorch that relies on GloVe. I begin by loading and preparing my data, sub-setting it to yield only two classes.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># prepare and load data</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">def</span> prepare_df(pkl_location):</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="co"># read pkl as pandas</span></a>
<a class="sourceLine" id="cb7-4" title="4">    df <span class="op">=</span> pd.read_pickle(pkl_location)</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="co"># just keep us/kabul labels</span></a>
<a class="sourceLine" id="cb7-6" title="6">    df <span class="op">=</span> df.loc[(df[<span class="st">&#39;target&#39;</span>] <span class="op">==</span> <span class="st">&#39;US&#39;</span>) <span class="op">|</span> (df[<span class="st">&#39;target&#39;</span>] <span class="op">==</span> <span class="st">&#39;Kabul&#39;</span>)]</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="co"># mask DV to recode</span></a>
<a class="sourceLine" id="cb7-8" title="8">    us <span class="op">=</span> df[<span class="st">&#39;target&#39;</span>] <span class="op">==</span> <span class="st">&#39;US&#39;</span></a>
<a class="sourceLine" id="cb7-9" title="9">    kabul <span class="op">=</span> df[<span class="st">&#39;target&#39;</span>] <span class="op">==</span> <span class="st">&#39;Kabul&#39;</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="co"># apply mask</span></a>
<a class="sourceLine" id="cb7-11" title="11">    df.loc[us, <span class="st">&#39;target&#39;</span>] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-12" title="12">    df.loc[kabul, <span class="st">&#39;target&#39;</span>] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="co"># reset index</span></a>
<a class="sourceLine" id="cb7-14" title="14">    df <span class="op">=</span> df.reset_index(drop<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="cf">return</span> df</a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">df <span class="op">=</span> prepare_df(<span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">Andrew</span><span class="ch">\\</span><span class="st">Desktop</span><span class="ch">\\</span><span class="st">df.pkl&#39;</span>)</a></code></pre></div>
<p>Next, I do a small amount of additional data cleaning to my text, as described below.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># prepare data</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">def</span> clean_df(df):</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="co"># strip dash but keep a space</span></a>
<a class="sourceLine" id="cb8-4" title="4">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">str</span>.replace(<span class="st">&#39;-&#39;</span>, <span class="st">&#39; &#39;</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="co"># prepare keys for punctuation removal</span></a>
<a class="sourceLine" id="cb8-6" title="6">    translator <span class="op">=</span> <span class="bu">str</span>.maketrans(<span class="bu">dict</span>.fromkeys(string.punctuation))</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="co"># lower case the data</span></a>
<a class="sourceLine" id="cb8-8" title="8">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.lower())</a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="co"># remove excess spaces near punctuation</span></a>
<a class="sourceLine" id="cb8-10" title="10">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: re.sub(<span class="vs">r&#39;\s([?.!&quot;](?:\s|$))&#39;</span>, <span class="vs">r&#39;\1&#39;</span>, x))</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="co"># remove punctuation  -- f1 improves by .05 by disabling this</span></a>
<a class="sourceLine" id="cb8-12" title="12">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: x.translate(translator))</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="co"># generate a word count</span></a>
<a class="sourceLine" id="cb8-14" title="14">    df[<span class="st">&#39;word_count&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="bu">len</span>(x.split()))</a>
<a class="sourceLine" id="cb8-15" title="15">    <span class="co"># remove excess white spaces</span></a>
<a class="sourceLine" id="cb8-16" title="16">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">&quot; &quot;</span>.join(x.split()))</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="cf">return</span> df</a>
<a class="sourceLine" id="cb8-19" title="19">    </a>
<a class="sourceLine" id="cb8-20" title="20">df <span class="op">=</span> clean_df(df)</a></code></pre></div>
<p>Since my corpus includes transliterations of Afghan words, there are a sizable amount of words that are not in the GloVe embedding and are otherwise probably not very helpful to helping us understand important local features through the lens of a CNN even if we were to give them coefficients for an unknown word. As such, I remove rare words from my corpus by:</p>
<ol style="list-style-type: decimal">
<li>collecting counts of each word in a key:value pair dictionary</li>
<li>removing keys from the dictionary if used less than twice</li>
<li>using <code>filter</code> to drop the rare words from the list</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># lets remove rare words</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">def</span> remove_rare_words(df):</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="co"># get counts of each word -- necessary for vocab</span></a>
<a class="sourceLine" id="cb9-4" title="4">    counts <span class="op">=</span> Counter(<span class="st">&quot; &quot;</span>.join(df[<span class="st">&#39;body&#39;</span>].values.tolist()).split(<span class="st">&quot; &quot;</span>))</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="co"># remove low counts -- keep those above 2</span></a>
<a class="sourceLine" id="cb9-6" title="6">    counts <span class="op">=</span> {key: value <span class="cf">for</span> key, value <span class="kw">in</span> counts.items() <span class="cf">if</span> value <span class="op">&gt;</span> <span class="dv">2</span>}</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="co"># remove rare words from corpus</span></a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="kw">def</span> remove_rare(x):</a>
<a class="sourceLine" id="cb9-10" title="10">        <span class="cf">return</span> <span class="st">&#39; &#39;</span>.join(<span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="kw">in</span> counts.keys(), x.split())))</a>
<a class="sourceLine" id="cb9-11" title="11"></a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="co"># apply funx</span></a>
<a class="sourceLine" id="cb9-13" title="13">    df[<span class="st">&#39;body&#39;</span>] <span class="op">=</span> df[<span class="st">&#39;body&#39;</span>].<span class="bu">apply</span>(remove_rare)</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="cf">return</span> df</a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"></a>
<a class="sourceLine" id="cb9-17" title="17">df <span class="op">=</span> remove_rare_words(df)</a></code></pre></div>
<p>Next, I execute a few functions to clean up the data set further and to learn a bit more about my corpus in its entirety.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="co"># find min/max word count</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="bu">max</span>(df[<span class="st">&#39;word_count&#39;</span>])</a></code></pre></div>
<pre><code>## 5472</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="bu">min</span>(df[<span class="st">&#39;word_count&#39;</span>])</a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co"># trim the corpus of really small messages</span></a></code></pre></div>
<pre><code>## 0</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">df <span class="op">=</span> df.loc[df[<span class="st">&#39;word_count&#39;</span>] <span class="op">&gt;</span> <span class="dv">20</span>]</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co"># what is 95th percentile of word count?</span></a>
<a class="sourceLine" id="cb14-4" title="4">percentile_95 <span class="op">=</span> <span class="bu">int</span>(df[<span class="st">&#39;word_count&#39;</span>].quantile(<span class="fl">0.95</span>))</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="bu">print</span>(percentile_95)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co"># whats the length of the vocab?</span></a></code></pre></div>
<pre><code>## 974</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1">counts <span class="op">=</span> Counter(<span class="st">&quot; &quot;</span>.join(df[<span class="st">&#39;body&#39;</span>].values.tolist()).split(<span class="st">&quot; &quot;</span>))</a>
<a class="sourceLine" id="cb16-2" title="2">vocab <span class="op">=</span> <span class="bu">sorted</span>(counts, key<span class="op">=</span>counts.get, reverse<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="bu">print</span>(<span class="bu">len</span>(vocab))</a></code></pre></div>
<pre><code>## 16354</code></pre>
<p>Now I am ready to load my GloVe embeddings.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1"><span class="co"># load GloVe embeddings</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="kw">def</span> load_GloVe(file_path):</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="co"># create empty dict to store data</span></a>
<a class="sourceLine" id="cb18-4" title="4">    embeddings_dictionary <span class="op">=</span> <span class="bu">dict</span>()</a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="co"># load the file</span></a>
<a class="sourceLine" id="cb18-6" title="6">    glove_file <span class="op">=</span> <span class="bu">open</span>(file_path, encoding<span class="op">=</span><span class="st">&quot;utf8&quot;</span>)</a>
<a class="sourceLine" id="cb18-7" title="7">    <span class="co"># for each entry</span></a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="cf">for</span> line <span class="kw">in</span> glove_file:</a>
<a class="sourceLine" id="cb18-9" title="9">        <span class="co"># split on spaces</span></a>
<a class="sourceLine" id="cb18-10" title="10">        records <span class="op">=</span> line.split()</a>
<a class="sourceLine" id="cb18-11" title="11">        <span class="co"># get the word located in position 0</span></a>
<a class="sourceLine" id="cb18-12" title="12">        word <span class="op">=</span> records[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb18-13" title="13">        <span class="co"># get the embeddings which is the remainder</span></a>
<a class="sourceLine" id="cb18-14" title="14">        vector_dimensions <span class="op">=</span> np.asarray(records[<span class="dv">1</span>:], dtype<span class="op">=</span><span class="st">&#39;float32&#39;</span>)</a>
<a class="sourceLine" id="cb18-15" title="15">        <span class="co"># add to dictionary</span></a>
<a class="sourceLine" id="cb18-16" title="16">        embeddings_dictionary[word] <span class="op">=</span> vector_dimensions</a>
<a class="sourceLine" id="cb18-17" title="17">    <span class="co"># close the file</span></a>
<a class="sourceLine" id="cb18-18" title="18">    glove_file.close()</a>
<a class="sourceLine" id="cb18-19" title="19">    <span class="cf">return</span> embeddings_dictionary</a>
<a class="sourceLine" id="cb18-20" title="20"></a>
<a class="sourceLine" id="cb18-21" title="21"></a>
<a class="sourceLine" id="cb18-22" title="22"><span class="co"># load GloVe</span></a>
<a class="sourceLine" id="cb18-23" title="23">file_path <span class="op">=</span> <span class="st">&#39;C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">Andrew</span><span class="ch">\\</span><span class="st">Desktop</span><span class="ch">\\</span><span class="st">glove.6B.200d.txt&#39;</span></a>
<a class="sourceLine" id="cb18-24" title="24">embeddings_dictionary <span class="op">=</span> load_GloVe(file_path)</a>
<a class="sourceLine" id="cb18-25" title="25"></a>
<a class="sourceLine" id="cb18-26" title="26"><span class="co"># useful computing to check vector values and indices</span></a>
<a class="sourceLine" id="cb18-27" title="27">embeddings_dictionary.get(<span class="st">&#39;.&#39;</span>)  <span class="co"># get key value</span></a></code></pre></div>
<pre><code>## array([ 1.2289e-01,  5.8037e-01, -6.9635e-02, -5.0288e-01,  1.0503e-01,
##         3.9945e-01, -3.8635e-01, -8.4279e-02,  1.2219e-01,  8.0312e-02,
##         3.2337e-01,  4.7579e-01, -3.8375e-02, -7.0900e-03,  4.1524e-01,
##         3.2121e-01, -2.1185e-01,  3.6144e-01, -5.5623e-02, -3.0512e-02,
##         4.2854e-01,  2.8547e+00, -1.4623e-01, -1.7557e-01,  3.1197e-01,
##        -1.3118e-01,  3.3298e-02,  1.3093e-01,  8.9889e-02, -1.2417e-01,
##         2.3396e-03, -6.8954e-02, -1.0754e-01, -1.1551e-01, -3.1052e-01,
##        -1.2097e-01, -4.6691e-01, -8.3600e-02, -3.7664e-02, -7.1779e-02,
##        -1.1899e-01, -2.0381e-01, -1.2424e-01,  4.6339e-01, -1.9828e-01,
##        -8.0365e-03,  5.3718e-01,  3.1739e-02,  3.4331e-01,  7.9704e-03,
##         4.8744e-03,  3.0592e-02, -1.7615e-01,  8.2342e-01, -1.3793e-01,
##        -1.0075e-01, -1.2686e-01,  7.4735e-02, -8.8719e-02, -4.2719e-02,
##         7.6624e-02,  8.9263e-02,  6.4445e-02, -3.1958e-02,  1.5254e-01,
##        -1.0384e-01,  7.6604e-02,  3.4099e-01,  2.4331e-01, -1.0452e-01,
##         4.0714e-01, -1.8260e-01, -4.0667e-02,  5.0878e-01,  8.0760e-02,
##         2.2759e-01, -4.2162e-02, -1.8171e-01, -9.5025e-02,  3.0334e-02,
##         8.8202e-02, -3.9843e-06, -3.9877e-03,  1.5724e-01,  3.3167e-01,
##         8.4710e-02, -2.5919e-01, -4.1384e-01,  2.9920e-01, -5.4255e-01,
##         3.2129e-02,  1.0030e-01,  4.4202e-01,  4.4682e-02, -9.0681e-02,
##        -1.0481e-01, -1.1860e-01, -3.1972e-01, -2.0790e-01, -4.0203e-02,
##        -2.2988e-02,  2.2824e-01,  5.5238e-03,  1.2568e-01, -1.4640e-01,
##        -1.4904e-01, -1.1561e-01,  1.0517e+00, -1.9498e-01,  8.3958e-02,
##         4.4812e-02, -1.2965e-01, -9.3468e-02,  2.1237e-01, -8.8332e-02,
##        -1.8680e-01,  2.6521e-01,  1.3097e-01, -4.8102e-02, -2.2467e-01,
##         2.8412e-01,  3.4907e-01,  3.4833e-01,  1.7877e-02,  3.0504e-01,
##        -8.3453e-01,  4.8856e-02, -1.9330e-01,  2.0764e-01, -4.9701e-01,
##        -1.8747e-01, -7.6801e-02,  1.5558e-01, -4.6844e-01,  4.0944e-01,
##         2.1386e-01,  8.2392e-02, -2.6491e-01, -2.1224e-01, -1.3293e-01,
##         1.4738e-01, -1.4192e-01,  1.8994e-01, -1.5587e-01,  1.0738e+00,
##         4.0789e-01, -2.7452e-01, -1.8431e-01,  6.8679e-04, -8.7115e-02,
##         1.9672e-01,  4.0918e-01, -3.5462e-01, -6.3260e-02,  4.4920e-01,
##        -6.0568e-02, -4.1636e-02,  2.0531e-01,  1.7025e-02, -5.8448e-01,
##         7.5441e-02,  8.2116e-02, -4.6008e-01,  1.2393e-02, -2.5310e-02,
##         1.4177e-01, -9.2192e-02,  3.4505e-01, -5.2136e-01,  5.7304e-01,
##         1.1973e-02,  3.3196e-02,  2.9672e-01, -2.7899e-01,  1.9979e-01,
##         2.5666e-01,  8.2079e-02, -7.8436e-02,  9.3719e-02,  2.4202e-01,
##         1.3495e+00, -3.0434e-01, -3.0936e-01,  4.2047e-01, -7.9068e-02,
##        -1.4819e-01, -8.9404e-02,  6.6800e-02,  2.2405e-01,  2.7226e-01,
##        -3.5236e-02,  1.7688e-01, -5.3600e-02,  7.0031e-03, -3.3006e-02,
##        -8.0021e-02, -2.4451e-01, -3.9174e-02, -1.6236e-01, -9.6652e-02],
##       dtype=float32)</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1"><span class="bu">list</span>(embeddings_dictionary.keys()).index(<span class="st">&#39;.&#39;</span>)  <span class="co"># get key index</span></a></code></pre></div>
<pre><code>## 2</code></pre>
<p>One issue I see with many guides that use GloVe is that they do not do anything to account for padding tokens nor for unknown words. The function remedies that in several ways:</p>
<ol style="list-style-type: decimal">
<li>It creates one nearly empty vector for the <em>padding</em> tokens.</li>
<li>It creates a randomly initialized vector between <span class="math inline">\([-0.14, 0.14]\)</span> (mimicking the variance of 200d GLoVe) to account for <em>unknown</em> tokens.</li>
<li>It extends the GloVe dimensions from 200 to 201 to account for this variation.</li>
</ol>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1"><span class="co"># create vectors for &quot;unknown&quot; and &quot;padding&quot; and add to GloVe</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">def</span> modify_GloVe(embeddings_dictionary):</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="co"># create key values for unknown</span></a>
<a class="sourceLine" id="cb22-4" title="4">    unknown_vector <span class="op">=</span> np.random.uniform(<span class="op">-</span><span class="fl">0.14</span>, <span class="fl">0.14</span>, <span class="dv">201</span>)  <span class="co"># var of GloVe 200d</span></a>
<a class="sourceLine" id="cb22-5" title="5">    <span class="co"># create key values for padding</span></a>
<a class="sourceLine" id="cb22-6" title="6">    pad_vector <span class="op">=</span> np.repeat(<span class="dv">0</span>, <span class="dv">200</span>)</a>
<a class="sourceLine" id="cb22-7" title="7">    pad_vector <span class="op">=</span> np.append(pad_vector, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-8" title="8">    <span class="co"># turn dict into list to append easily</span></a>
<a class="sourceLine" id="cb22-9" title="9">    embeddings_tensor <span class="op">=</span> <span class="bu">list</span>(embeddings_dictionary.values())</a>
<a class="sourceLine" id="cb22-10" title="10">    <span class="co"># extend GloVe dimension by 2</span></a>
<a class="sourceLine" id="cb22-11" title="11">    embeddings_tensor <span class="op">=</span> [np.append(i, <span class="dv">0</span>) <span class="cf">for</span> i <span class="kw">in</span> embeddings_tensor]</a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="co"># add unknown and pad vectors via vstack</span></a>
<a class="sourceLine" id="cb22-13" title="13">    embeddings_tensor <span class="op">=</span> np.vstack([embeddings_tensor, unknown_vector])</a>
<a class="sourceLine" id="cb22-14" title="14">    embeddings_tensor <span class="op">=</span> np.vstack([embeddings_tensor, pad_vector])</a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="co"># finalize transform into tensor</span></a>
<a class="sourceLine" id="cb22-16" title="16">    embeddings_tensor <span class="op">=</span> torch.Tensor(embeddings_tensor)</a>
<a class="sourceLine" id="cb22-17" title="17">    <span class="cf">return</span> embeddings_tensor</a>
<a class="sourceLine" id="cb22-18" title="18">    </a>
<a class="sourceLine" id="cb22-19" title="19"><span class="co"># modify GloVe and turn into torch tensor</span></a>
<a class="sourceLine" id="cb22-20" title="20">embeddings_tensor <span class="op">=</span> modify_GloVe(embeddings_dictionary)</a>
<a class="sourceLine" id="cb22-21" title="21"><span class="co"># check shape</span></a>
<a class="sourceLine" id="cb22-22" title="22"><span class="bu">print</span>(embeddings_tensor.shape)</a></code></pre></div>
<pre><code>## torch.Size([400002, 201])</code></pre>
<p>With GloVe loaded, we need to tokenize our corpus into GloVe tokens. This is because when we feed our tokens into the model, it uses an <code>embedding</code> layer that acts as a look-up table. We will eventually specify that this look-up table be the object we just created, <code>embeddings_tensor</code>, so that when a token is fed into our model, the <code>embedding</code> layer will “look-up” the 200 dimension feature for that word inside the <code>embeddings_tensor</code> object and append the features to our batch undergoing forward propagation.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"><span class="co"># convert strings to GloVe familiar tokens</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">def</span> text_to_GloVe_tokens(df, embeddings_dictionary):</a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="co"># create container for words that do not match</span></a>
<a class="sourceLine" id="cb24-4" title="4">    no_matches <span class="op">=</span> []</a>
<a class="sourceLine" id="cb24-5" title="5">    <span class="co"># create container for tokenized strings</span></a>
<a class="sourceLine" id="cb24-6" title="6">    glove_tokenized_data <span class="op">=</span> []</a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="co"># create lookup for token ids</span></a>
<a class="sourceLine" id="cb24-8" title="8">    word_map <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(embeddings_dictionary.keys(), <span class="bu">range</span>(<span class="bu">len</span>(embeddings_dictionary))))</a>
<a class="sourceLine" id="cb24-9" title="9">    <span class="co"># for each document</span></a>
<a class="sourceLine" id="cb24-10" title="10">    <span class="cf">for</span> doc <span class="kw">in</span> df[<span class="st">&#39;body&#39;</span>]:</a>
<a class="sourceLine" id="cb24-11" title="11">        <span class="co"># split each string</span></a>
<a class="sourceLine" id="cb24-12" title="12">        doc <span class="op">=</span> doc.split()</a>
<a class="sourceLine" id="cb24-13" title="13">        <span class="co"># create token container</span></a>
<a class="sourceLine" id="cb24-14" title="14">        tokens <span class="op">=</span> []</a>
<a class="sourceLine" id="cb24-15" title="15">        <span class="co"># for each word in the document</span></a>
<a class="sourceLine" id="cb24-16" title="16">        <span class="cf">for</span> word <span class="kw">in</span> doc:</a>
<a class="sourceLine" id="cb24-17" title="17">            <span class="co"># if word is a GloVE word</span></a>
<a class="sourceLine" id="cb24-18" title="18">            <span class="cf">if</span> word <span class="kw">in</span> word_map:</a>
<a class="sourceLine" id="cb24-19" title="19">                <span class="co"># get its GloVe index</span></a>
<a class="sourceLine" id="cb24-20" title="20">                idx <span class="op">=</span> word_map.get(word)</a>
<a class="sourceLine" id="cb24-21" title="21">                <span class="co"># save its token</span></a>
<a class="sourceLine" id="cb24-22" title="22">                tokens.append(idx)</a>
<a class="sourceLine" id="cb24-23" title="23">            <span class="co"># otherwise</span></a>
<a class="sourceLine" id="cb24-24" title="24">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb24-25" title="25">                <span class="co"># it must be an unknown word to GloVe</span></a>
<a class="sourceLine" id="cb24-26" title="26">                idx <span class="op">=</span> <span class="dv">400000</span>  <span class="co"># unknown word</span></a>
<a class="sourceLine" id="cb24-27" title="27">                <span class="co"># so append that word to no matches</span></a>
<a class="sourceLine" id="cb24-28" title="28">                no_matches.append(word)</a>
<a class="sourceLine" id="cb24-29" title="29">                <span class="co"># but also give it a vector lookup</span></a>
<a class="sourceLine" id="cb24-30" title="30">                tokens.append(idx)</a>
<a class="sourceLine" id="cb24-31" title="31">        <span class="co"># combine the tokens</span></a>
<a class="sourceLine" id="cb24-32" title="32">        glove_tokenized_data.append(tokens)</a>
<a class="sourceLine" id="cb24-33" title="33">    <span class="cf">return</span> no_matches, glove_tokenized_data</a></code></pre></div>
<p>With our corpus tokenized to match GloVe, it is in our interest to know just how many words in our corpus have no embedding features. The code below determines that for us.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="co"># get a list of no matches and our GloVe tokens</span></a>
<a class="sourceLine" id="cb25-2" title="2">no_matches, glove_tokenized_data <span class="op">=</span> text_to_GloVe_tokens(df, embeddings_dictionary)</a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co"># after removing rare words, how many words are we not accounting for now?</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="bu">print</span>(<span class="bu">len</span>(<span class="bu">set</span>(no_matches)))</a></code></pre></div>
<pre><code>## 1495</code></pre>
<p>Our next challenge is managing the lengths of our messages as they all need to be equal. The function below receives the GloVe tokenized data and a specified max length. It then proceeds to check the size of each item in the corpus and then either truncates or adds our new specialized padding token to the end of the message.</p>
<p><code>max_len</code> is a hyperparameter that we can experiment with, however, I have chosen the 95th percentile of my corpus’ <code>word_count</code> as my desired max length.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1"><span class="co"># post pad GloVe</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">def</span> pad_GloVe(tokenized_data, max_len):</a>
<a class="sourceLine" id="cb27-3" title="3">    padded_tokens <span class="op">=</span> []</a>
<a class="sourceLine" id="cb27-4" title="4">    max_len <span class="op">=</span> max_len</a>
<a class="sourceLine" id="cb27-5" title="5">    <span class="co"># for each tokenized document</span></a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="cf">for</span> tokenized_sent <span class="kw">in</span> tokenized_data:</a>
<a class="sourceLine" id="cb27-7" title="7">        <span class="co"># if current doc length is greater than max length</span></a>
<a class="sourceLine" id="cb27-8" title="8">        <span class="cf">if</span> <span class="bu">len</span>(tokenized_sent) <span class="op">&gt;</span> max_len:</a>
<a class="sourceLine" id="cb27-9" title="9">            <span class="co"># trim it to max length</span></a>
<a class="sourceLine" id="cb27-10" title="10">            current_sent <span class="op">=</span> tokenized_sent[:max_len]</a>
<a class="sourceLine" id="cb27-11" title="11">            <span class="co"># append</span></a>
<a class="sourceLine" id="cb27-12" title="12">            padded_tokens.append(current_sent)</a>
<a class="sourceLine" id="cb27-13" title="13"></a>
<a class="sourceLine" id="cb27-14" title="14">        <span class="co"># if current doc length is less than max length</span></a>
<a class="sourceLine" id="cb27-15" title="15">        <span class="cf">if</span> <span class="bu">len</span>(tokenized_sent) <span class="op">&lt;</span> max_len:</a>
<a class="sourceLine" id="cb27-16" title="16">            <span class="co"># find the difference in length</span></a>
<a class="sourceLine" id="cb27-17" title="17">            extension <span class="op">=</span> max_len <span class="op">-</span> <span class="bu">len</span>(tokenized_sent)</a>
<a class="sourceLine" id="cb27-18" title="18">            <span class="co"># pad sentences to max_len</span></a>
<a class="sourceLine" id="cb27-19" title="19">            tokenized_sent.extend(repeat(<span class="dv">400001</span>, extension))</a>
<a class="sourceLine" id="cb27-20" title="20">            <span class="co"># append new padded token</span></a>
<a class="sourceLine" id="cb27-21" title="21">            padded_tokens.append(tokenized_sent)</a>
<a class="sourceLine" id="cb27-22" title="22"></a>
<a class="sourceLine" id="cb27-23" title="23">        <span class="cf">elif</span> <span class="bu">len</span>(tokenized_sent) <span class="op">==</span> max_len:</a>
<a class="sourceLine" id="cb27-24" title="24">            padded_tokens.append(tokenized_sent)</a>
<a class="sourceLine" id="cb27-25" title="25"></a>
<a class="sourceLine" id="cb27-26" title="26">    <span class="cf">return</span> np.array(padded_tokens, dtype<span class="op">=</span>np.int64)</a>
<a class="sourceLine" id="cb27-27" title="27"></a>
<a class="sourceLine" id="cb27-28" title="28"><span class="co"># get new padded tokens</span></a>
<a class="sourceLine" id="cb27-29" title="29">padded_GloVe <span class="op">=</span> pad_GloVe(glove_tokenized_data, percentile_95)</a>
<a class="sourceLine" id="cb27-30" title="30"><span class="co"># check shape; 9994 documents, 974 length</span></a>
<a class="sourceLine" id="cb27-31" title="31"><span class="bu">print</span>(padded_GloVe.shape)</a>
<a class="sourceLine" id="cb27-32" title="32"></a>
<a class="sourceLine" id="cb27-33" title="33"><span class="co"># check to make sure padding done right</span></a></code></pre></div>
<pre><code>## (10041, 974)</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1"><span class="bu">print</span>([i <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(padded_GloVe) <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">!=</span> percentile_95])    </a></code></pre></div>
<pre><code>## []</code></pre>
<p>With the corpus work out of the way, we now proceed to prepare our data for analysis in PyTorch. The code below creates a <code>TensorDataset</code> comprised of our features, padded GloVe tokens, and our labels. It then proceeds to spit the data sets into train, validation, and test sets.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1"><span class="co"># prepare tensor data sets</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">def</span> prepare_dataset(padded_tokens, target):</a>
<a class="sourceLine" id="cb31-3" title="3">    <span class="co"># prepare target into np array</span></a>
<a class="sourceLine" id="cb31-4" title="4">    target <span class="op">=</span> np.array(target.values, dtype<span class="op">=</span>np.int64).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb31-5" title="5">    <span class="co"># create tensor data sets</span></a>
<a class="sourceLine" id="cb31-6" title="6">    tensor_df <span class="op">=</span> TensorDataset(torch.from_numpy(padded_tokens), torch.from_numpy(target))</a>
<a class="sourceLine" id="cb31-7" title="7">    <span class="co"># 80% of df</span></a>
<a class="sourceLine" id="cb31-8" title="8">    train_size <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.8</span> <span class="op">*</span> <span class="bu">len</span>(df))</a>
<a class="sourceLine" id="cb31-9" title="9">    <span class="co"># 20% of df</span></a>
<a class="sourceLine" id="cb31-10" title="10">    val_size <span class="op">=</span> <span class="bu">len</span>(df) <span class="op">-</span> train_size</a>
<a class="sourceLine" id="cb31-11" title="11">    <span class="co"># 50% of validation</span></a>
<a class="sourceLine" id="cb31-12" title="12">    test_size <span class="op">=</span> <span class="bu">int</span>(val_size <span class="op">-</span> <span class="fl">0.5</span><span class="op">*</span>val_size)</a>
<a class="sourceLine" id="cb31-13" title="13">    <span class="co"># divide the dataset by randomly selecting samples</span></a>
<a class="sourceLine" id="cb31-14" title="14">    train_dataset, val_dataset <span class="op">=</span> random_split(tensor_df, [train_size, val_size])</a>
<a class="sourceLine" id="cb31-15" title="15">    <span class="co"># divide validation by randomly selecting samples</span></a>
<a class="sourceLine" id="cb31-16" title="16">    val_dataset, test_dataset <span class="op">=</span> random_split(val_dataset, [test_size, test_size<span class="op">+</span><span class="dv">1</span>])</a>
<a class="sourceLine" id="cb31-17" title="17"></a>
<a class="sourceLine" id="cb31-18" title="18">    <span class="cf">return</span> train_dataset, val_dataset, test_dataset</a>
<a class="sourceLine" id="cb31-19" title="19"></a>
<a class="sourceLine" id="cb31-20" title="20"><span class="co"># create tenor data sets</span></a>
<a class="sourceLine" id="cb31-21" title="21">train_dataset, val_dataset, test_dataset <span class="op">=</span> prepare_dataset(padded_GloVe, df[<span class="st">&#39;target&#39;</span>])</a></code></pre></div>
<p>Since my corpus is imbalanced, I produce weighted samplers to help balance the distribution of data as it is fed outside of my data loaders.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb32-1" title="1"><span class="co"># helper function to count target distribution inside tensor data sets</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="kw">def</span> target_count(tensor_dataset):</a>
<a class="sourceLine" id="cb32-3" title="3">    <span class="co"># set empty count containers</span></a>
<a class="sourceLine" id="cb32-4" title="4">    count0 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb32-5" title="5">    count1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="co"># set total container to turn into torch tensor</span></a>
<a class="sourceLine" id="cb32-7" title="7">    total <span class="op">=</span> []</a>
<a class="sourceLine" id="cb32-8" title="8">    <span class="co"># for every item in the tensor data set</span></a>
<a class="sourceLine" id="cb32-9" title="9">    <span class="cf">for</span> i <span class="kw">in</span> tensor_dataset:</a>
<a class="sourceLine" id="cb32-10" title="10">        <span class="co"># if the target is equal to 0</span></a>
<a class="sourceLine" id="cb32-11" title="11">        <span class="cf">if</span> i[<span class="dv">1</span>].item() <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb32-12" title="12">            count0 <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb32-13" title="13">        <span class="co"># if the target is equal to 1</span></a>
<a class="sourceLine" id="cb32-14" title="14">        <span class="cf">elif</span> i[<span class="dv">1</span>].item() <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb32-15" title="15">            count1 <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb32-16" title="16">    total.append(count0)</a>
<a class="sourceLine" id="cb32-17" title="17">    total.append(count1)</a>
<a class="sourceLine" id="cb32-18" title="18">    <span class="cf">return</span> torch.tensor(total)</a>
<a class="sourceLine" id="cb32-19" title="19"></a>
<a class="sourceLine" id="cb32-20" title="20"></a>
<a class="sourceLine" id="cb32-21" title="21"><span class="co"># prepare weighted sampling for imbalanced classification</span></a>
<a class="sourceLine" id="cb32-22" title="22"><span class="kw">def</span> create_sampler(target_tensor, tensor_dataset):</a>
<a class="sourceLine" id="cb32-23" title="23">    <span class="co"># generate class distributions [x, y]</span></a>
<a class="sourceLine" id="cb32-24" title="24">    class_sample_count <span class="op">=</span> target_count(tensor_dataset)</a>
<a class="sourceLine" id="cb32-25" title="25">    <span class="co"># weight</span></a>
<a class="sourceLine" id="cb32-26" title="26">    weight <span class="op">=</span> <span class="fl">1.</span> <span class="op">/</span> class_sample_count.<span class="bu">float</span>()</a>
<a class="sourceLine" id="cb32-27" title="27">    <span class="co"># produce weights for each observation in the data set</span></a>
<a class="sourceLine" id="cb32-28" title="28">    samples_weight <span class="op">=</span> torch.tensor([weight[t[<span class="dv">1</span>]] <span class="cf">for</span> t <span class="kw">in</span> tensor_dataset])</a>
<a class="sourceLine" id="cb32-29" title="29">    <span class="co"># prepare sampler</span></a>
<a class="sourceLine" id="cb32-30" title="30">    sampler <span class="op">=</span> torch.utils.data.WeightedRandomSampler(weights<span class="op">=</span>samples_weight,</a>
<a class="sourceLine" id="cb32-31" title="31">                                                     num_samples<span class="op">=</span><span class="bu">len</span>(samples_weight),</a>
<a class="sourceLine" id="cb32-32" title="32">                                                     replacement<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb32-33" title="33">    <span class="cf">return</span> sampler</a>
<a class="sourceLine" id="cb32-34" title="34"></a>
<a class="sourceLine" id="cb32-35" title="35"></a>
<a class="sourceLine" id="cb32-36" title="36"><span class="co"># create samplers for just training</span></a>
<a class="sourceLine" id="cb32-37" title="37">train_sampler <span class="op">=</span> create_sampler(target_count(train_dataset), train_dataset)</a></code></pre></div>
<p>As you might have guessed, preparing data loaders for each of our train, dev, and test data sets is our next task.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb33-1" title="1"><span class="co"># create DataLoaders with samplers</span></a>
<a class="sourceLine" id="cb33-2" title="2">train_dataloader <span class="op">=</span> DataLoader(train_dataset,</a>
<a class="sourceLine" id="cb33-3" title="3">                              batch_size<span class="op">=</span><span class="dv">80</span>,</a>
<a class="sourceLine" id="cb33-4" title="4">                              sampler<span class="op">=</span>train_sampler,</a>
<a class="sourceLine" id="cb33-5" title="5">                              shuffle<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7">valid_dataloader <span class="op">=</span> DataLoader(val_dataset,</a>
<a class="sourceLine" id="cb33-8" title="8">                              batch_size<span class="op">=</span><span class="dv">80</span>,</a>
<a class="sourceLine" id="cb33-9" title="9">                              shuffle<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb33-10" title="10"></a>
<a class="sourceLine" id="cb33-11" title="11">test_dataloader <span class="op">=</span> DataLoader(test_dataset,</a>
<a class="sourceLine" id="cb33-12" title="12">                              batch_size<span class="op">=</span><span class="dv">80</span>,</a>
<a class="sourceLine" id="cb33-13" title="13">                              shuffle<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>We can check to see how our sampler is working by running the loop below. As we can see, the data loader is outputting relatively balanced data into each batch.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb34-1" title="1"><span class="co"># lets check class balance for each batch to see how the sampler is working</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(train_dataloader):</a>
<a class="sourceLine" id="cb34-3" title="3">    <span class="cf">if</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>):</a>
<a class="sourceLine" id="cb34-4" title="4">        <span class="bu">print</span>(<span class="st">&quot;batch index </span><span class="sc">{}</span><span class="st">, 0/1: </span><span class="sc">{}</span><span class="st">/</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(</a>
<a class="sourceLine" id="cb34-5" title="5">            i, (y <span class="op">==</span> <span class="dv">0</span>).<span class="bu">sum</span>(), (y <span class="op">==</span> <span class="dv">1</span>).<span class="bu">sum</span>()))</a></code></pre></div>
<pre><code>## batch index 0, 0/1: 45/35
## batch index 1, 0/1: 40/40
## batch index 2, 0/1: 36/44
## batch index 3, 0/1: 44/36
## batch index 4, 0/1: 43/37
## batch index 5, 0/1: 41/39
## batch index 6, 0/1: 46/34
## batch index 7, 0/1: 46/34
## batch index 8, 0/1: 37/43
## batch index 9, 0/1: 41/39</code></pre>
<p>Next, we build a Kim Yoon (2014) CNN designed to use GloVe embeddings.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb36-1" title="1"><span class="co"># Build Kim Yoon CNN</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="kw">class</span> KimCNN(nn.Module):</a>
<a class="sourceLine" id="cb36-3" title="3"></a>
<a class="sourceLine" id="cb36-4" title="4">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config):</a>
<a class="sourceLine" id="cb36-5" title="5">        <span class="bu">super</span>().<span class="fu">__init__</span>()</a>
<a class="sourceLine" id="cb36-6" title="6">        output_channel <span class="op">=</span> config.output_channel  <span class="co"># number of kernels</span></a>
<a class="sourceLine" id="cb36-7" title="7">        num_classes <span class="op">=</span> config.num_classes  <span class="co"># number of targets to predict</span></a>
<a class="sourceLine" id="cb36-8" title="8">        vocab_size <span class="op">=</span> config.vocab_size  <span class="co"># vocab size of corpus</span></a>
<a class="sourceLine" id="cb36-9" title="9">        embedding_dim <span class="op">=</span> config.embedding_dim  <span class="co"># GloVe embed dim size</span></a>
<a class="sourceLine" id="cb36-10" title="10">        pre_embed <span class="op">=</span> config.pre_embed  <span class="co"># GloVe coefs</span></a>
<a class="sourceLine" id="cb36-11" title="11">        <span class="va">self</span>.mode <span class="op">=</span> config.mode  <span class="co"># static, or not</span></a>
<a class="sourceLine" id="cb36-12" title="12">        ks <span class="op">=</span> <span class="dv">3</span>  <span class="co"># three conv nets here</span></a>
<a class="sourceLine" id="cb36-13" title="13">        dropout <span class="op">=</span> config.dropout  <span class="co"># dropout value</span></a>
<a class="sourceLine" id="cb36-14" title="14">        padding <span class="op">=</span> config.padding_idx  <span class="co"># padding indx value</span></a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16">        <span class="co"># for single embedding, input_channel = 1</span></a>
<a class="sourceLine" id="cb36-17" title="17">        input_channel <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb36-18" title="18">        <span class="cf">if</span> config.mode <span class="op">==</span> <span class="st">&#39;rand&#39;</span>:</a>
<a class="sourceLine" id="cb36-19" title="19">            rand_embed_init <span class="op">=</span> torch.Tensor(vocab_size, embedding_dim).uniform_(<span class="op">-</span><span class="fl">0.25</span>, <span class="fl">0.25</span>)</a>
<a class="sourceLine" id="cb36-20" title="20">            <span class="va">self</span>.embed <span class="op">=</span> nn.Embedding.from_pretrained(rand_embed_init, freeze<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb36-21" title="21"></a>
<a class="sourceLine" id="cb36-22" title="22">        <span class="cf">elif</span> config.mode <span class="op">==</span> <span class="st">&#39;static&#39;</span>:</a>
<a class="sourceLine" id="cb36-23" title="23">            <span class="va">self</span>.static_embed <span class="op">=</span> nn.Embedding.from_pretrained(pre_embed,</a>
<a class="sourceLine" id="cb36-24" title="24">                                                             freeze<span class="op">=</span><span class="va">True</span>,</a>
<a class="sourceLine" id="cb36-25" title="25">                                                             padding_idx<span class="op">=</span>padding)</a>
<a class="sourceLine" id="cb36-26" title="26"></a>
<a class="sourceLine" id="cb36-27" title="27">        <span class="cf">elif</span> config.mode <span class="op">==</span> <span class="st">&#39;non-static&#39;</span>:</a>
<a class="sourceLine" id="cb36-28" title="28">            <span class="va">self</span>.non_static_embed <span class="op">=</span> nn.Embedding.from_pretrained(pre_embed,</a>
<a class="sourceLine" id="cb36-29" title="29">                                                                 freeze<span class="op">=</span><span class="va">False</span>,</a>
<a class="sourceLine" id="cb36-30" title="30">                                                                 padding_idx<span class="op">=</span>padding)</a>
<a class="sourceLine" id="cb36-31" title="31"></a>
<a class="sourceLine" id="cb36-32" title="32">        <span class="co"># input channel increases with trainable and untrainable embeddings</span></a>
<a class="sourceLine" id="cb36-33" title="33">        <span class="cf">elif</span> config.mode <span class="op">==</span> <span class="st">&#39;multichannel&#39;</span>:</a>
<a class="sourceLine" id="cb36-34" title="34">            <span class="va">self</span>.static_embed <span class="op">=</span> nn.Embedding.from_pretrained(pre_embed,</a>
<a class="sourceLine" id="cb36-35" title="35">                                                             freeze<span class="op">=</span><span class="va">True</span>,</a>
<a class="sourceLine" id="cb36-36" title="36">                                                             padding_idx<span class="op">=</span>padding)</a>
<a class="sourceLine" id="cb36-37" title="37">            <span class="va">self</span>.non_static_embed <span class="op">=</span> nn.Embedding.from_pretrained(pre_embed,</a>
<a class="sourceLine" id="cb36-38" title="38">                                                                 freeze<span class="op">=</span><span class="va">False</span>,</a>
<a class="sourceLine" id="cb36-39" title="39">                                                                 padding_idx<span class="op">=</span>padding)</a>
<a class="sourceLine" id="cb36-40" title="40">            input_channel <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb36-41" title="41"></a>
<a class="sourceLine" id="cb36-42" title="42">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb36-43" title="43">            <span class="bu">print</span>(<span class="st">&quot;Unsupported Mode&quot;</span>)</a>
<a class="sourceLine" id="cb36-44" title="44">            <span class="cf">raise</span> <span class="pp">Exception</span></a>
<a class="sourceLine" id="cb36-45" title="45"></a>
<a class="sourceLine" id="cb36-46" title="46">        <span class="co"># input_channel = word embeddings at a value of 1; 3 for RGB images</span></a>
<a class="sourceLine" id="cb36-47" title="47">        <span class="co"># output_channel = number of kernels</span></a>
<a class="sourceLine" id="cb36-48" title="48">        <span class="co"># [3, 4, 5] = window height</span></a>
<a class="sourceLine" id="cb36-49" title="49">        <span class="co"># embedding_dim = length of embedding dim; my GloVe is 202</span></a>
<a class="sourceLine" id="cb36-50" title="50">        <span class="co"># padding = padding to account for height of search window</span></a>
<a class="sourceLine" id="cb36-51" title="51">        <span class="va">self</span>.conv1 <span class="op">=</span> nn.Conv2d(input_channel, output_channel, (<span class="dv">3</span>, embedding_dim), padding<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb36-52" title="52">        <span class="va">self</span>.conv2 <span class="op">=</span> nn.Conv2d(input_channel, output_channel, (<span class="dv">4</span>, embedding_dim), padding<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb36-53" title="53">        <span class="va">self</span>.conv3 <span class="op">=</span> nn.Conv2d(input_channel, output_channel, (<span class="dv">5</span>, embedding_dim), padding<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb36-54" title="54">        <span class="co"># apply dropout</span></a>
<a class="sourceLine" id="cb36-55" title="55">        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</a>
<a class="sourceLine" id="cb36-56" title="56">        <span class="co"># fully connected layer for classification</span></a>
<a class="sourceLine" id="cb36-57" title="57">        <span class="co"># 3x conv nets * output channel</span></a>
<a class="sourceLine" id="cb36-58" title="58">        <span class="va">self</span>.fc1 <span class="op">=</span> nn.Linear(ks <span class="op">*</span> output_channel, num_classes)</a>
<a class="sourceLine" id="cb36-59" title="59"></a>
<a class="sourceLine" id="cb36-60" title="60">    <span class="kw">def</span> forward(<span class="va">self</span>, x, <span class="op">**</span>kwargs):</a>
<a class="sourceLine" id="cb36-61" title="61">        <span class="cf">if</span> <span class="va">self</span>.mode <span class="op">==</span> <span class="st">&#39;rand&#39;</span>:</a>
<a class="sourceLine" id="cb36-62" title="62">            word_input <span class="op">=</span> <span class="va">self</span>.embed(x)  <span class="co"># (batch, sent_len, embed_dim)</span></a>
<a class="sourceLine" id="cb36-63" title="63">            x <span class="op">=</span> word_input.unsqueeze(<span class="dv">1</span>)  <span class="co"># (batch, channel_input, sent_len, embed_dim)</span></a>
<a class="sourceLine" id="cb36-64" title="64"></a>
<a class="sourceLine" id="cb36-65" title="65">        <span class="cf">elif</span> <span class="va">self</span>.mode <span class="op">==</span> <span class="st">&#39;static&#39;</span>:</a>
<a class="sourceLine" id="cb36-66" title="66">            static_input <span class="op">=</span> <span class="va">self</span>.static_embed(x)</a>
<a class="sourceLine" id="cb36-67" title="67">            x <span class="op">=</span> static_input.unsqueeze(<span class="dv">1</span>)  <span class="co"># (batch, channel_input, sent_len, embed_dim)</span></a>
<a class="sourceLine" id="cb36-68" title="68"></a>
<a class="sourceLine" id="cb36-69" title="69">        <span class="cf">elif</span> <span class="va">self</span>.mode <span class="op">==</span> <span class="st">&#39;non-static&#39;</span>:</a>
<a class="sourceLine" id="cb36-70" title="70">            non_static_input <span class="op">=</span> <span class="va">self</span>.non_static_embed(x)</a>
<a class="sourceLine" id="cb36-71" title="71">            x <span class="op">=</span> non_static_input.unsqueeze(<span class="dv">1</span>)  <span class="co"># (batch, channel_input, sent_len, embed_dim)</span></a>
<a class="sourceLine" id="cb36-72" title="72"></a>
<a class="sourceLine" id="cb36-73" title="73">        <span class="cf">elif</span> <span class="va">self</span>.mode <span class="op">==</span> <span class="st">&#39;multichannel&#39;</span>:</a>
<a class="sourceLine" id="cb36-74" title="74">            non_static_input <span class="op">=</span> <span class="va">self</span>.non_static_embed(x)</a>
<a class="sourceLine" id="cb36-75" title="75">            static_input <span class="op">=</span> <span class="va">self</span>.static_embed(x)</a>
<a class="sourceLine" id="cb36-76" title="76">            x <span class="op">=</span> torch.stack([non_static_input, static_input], dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># (batch, channel_input=2, sent_len, embed_dim)</span></a>
<a class="sourceLine" id="cb36-77" title="77"></a>
<a class="sourceLine" id="cb36-78" title="78">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb36-79" title="79">            <span class="bu">print</span>(<span class="st">&quot;Unsupported Mode&quot;</span>)</a>
<a class="sourceLine" id="cb36-80" title="80">            <span class="cf">raise</span> <span class="pp">Exception</span></a>
<a class="sourceLine" id="cb36-81" title="81"></a>
<a class="sourceLine" id="cb36-82" title="82">        <span class="co"># squeeze to get size; (batch, channel_output, ~=sent_len) * ks</span></a>
<a class="sourceLine" id="cb36-83" title="83">        x <span class="op">=</span> [F.relu(<span class="va">self</span>.conv1(x)).squeeze(<span class="dv">3</span>), F.relu(<span class="va">self</span>.conv2(x)).squeeze(<span class="dv">3</span>), F.relu(<span class="va">self</span>.conv3(x)).squeeze(<span class="dv">3</span>)]</a>
<a class="sourceLine" id="cb36-84" title="84">        <span class="co"># max-over-time pooling; # (batch, channel_output) * ks</span></a>
<a class="sourceLine" id="cb36-85" title="85">        x <span class="op">=</span> [F.max_pool1d(i, i.size(<span class="dv">2</span>)).squeeze(<span class="dv">2</span>) <span class="cf">for</span> i <span class="kw">in</span> x]</a>
<a class="sourceLine" id="cb36-86" title="86">        <span class="co"># concat results; (batch, channel_output * ks)</span></a>
<a class="sourceLine" id="cb36-87" title="87">        x <span class="op">=</span> torch.cat(x, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-88" title="88">        <span class="co"># add dropout</span></a>
<a class="sourceLine" id="cb36-89" title="89">        x <span class="op">=</span> <span class="va">self</span>.dropout(x)</a>
<a class="sourceLine" id="cb36-90" title="90">        <span class="co"># generate logits (batch, target_size)</span></a>
<a class="sourceLine" id="cb36-91" title="91">        logit <span class="op">=</span> <span class="va">self</span>.fc1(x)</a>
<a class="sourceLine" id="cb36-92" title="92">        <span class="cf">return</span> logit</a></code></pre></div>
<p>Below we instantiate a helper function for time keeping.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb37-1" title="1"><span class="co"># time function</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="kw">def</span> format_time(elapsed):</a>
<a class="sourceLine" id="cb37-3" title="3">    <span class="co">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="co">    Takes a time in seconds and returns a string hh:mm:ss</span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="co">    &#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb37-6" title="6">    <span class="co"># round to the nearest second.</span></a>
<a class="sourceLine" id="cb37-7" title="7">    elapsed_rounded <span class="op">=</span> <span class="bu">int</span>(<span class="bu">round</span>((elapsed)))</a>
<a class="sourceLine" id="cb37-8" title="8">    <span class="co"># format as hh:mm:ss</span></a>
<a class="sourceLine" id="cb37-9" title="9">    <span class="cf">return</span> <span class="bu">str</span>(datetime.timedelta(seconds<span class="op">=</span>elapsed_rounded))</a></code></pre></div>
<p>Now, we prepare functions to train, validate, and test our data.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">def</span> train(model, dataloader, optimizer, criterion):</a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3">    <span class="co"># capture time</span></a>
<a class="sourceLine" id="cb38-4" title="4">    total_t0 <span class="op">=</span> time.time()</a>
<a class="sourceLine" id="cb38-5" title="5"></a>
<a class="sourceLine" id="cb38-6" title="6">    <span class="co"># Perform one full pass over the training set.</span></a>
<a class="sourceLine" id="cb38-7" title="7">    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb38-8" title="8">    <span class="bu">print</span>(<span class="st">&#39;======== Epoch </span><span class="sc">{:}</span><span class="st"> / </span><span class="sc">{:}</span><span class="st"> ========&#39;</span>.<span class="bu">format</span>(epoch <span class="op">+</span> <span class="dv">1</span>, epochs))</a>
<a class="sourceLine" id="cb38-9" title="9">    <span class="bu">print</span>(<span class="st">&#39;Training...&#39;</span>)</a>
<a class="sourceLine" id="cb38-10" title="10"></a>
<a class="sourceLine" id="cb38-11" title="11">    <span class="co"># reset total loss for epoch</span></a>
<a class="sourceLine" id="cb38-12" title="12">    train_total_loss <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb38-13" title="13">    total_train_f1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb38-14" title="14"></a>
<a class="sourceLine" id="cb38-15" title="15">    <span class="co"># put model into traning mode</span></a>
<a class="sourceLine" id="cb38-16" title="16">    model.train()</a>
<a class="sourceLine" id="cb38-17" title="17"></a>
<a class="sourceLine" id="cb38-18" title="18">    <span class="co"># for each batch of training data...</span></a>
<a class="sourceLine" id="cb38-19" title="19">    <span class="cf">for</span> step, batch <span class="kw">in</span> <span class="bu">enumerate</span>(dataloader):</a>
<a class="sourceLine" id="cb38-20" title="20"></a>
<a class="sourceLine" id="cb38-21" title="21">        <span class="co"># progress update every 40 batches.</span></a>
<a class="sourceLine" id="cb38-22" title="22">        <span class="cf">if</span> step <span class="op">%</span> <span class="dv">40</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> <span class="kw">not</span> step <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb38-23" title="23"></a>
<a class="sourceLine" id="cb38-24" title="24">            <span class="co"># Report progress.</span></a>
<a class="sourceLine" id="cb38-25" title="25">            <span class="bu">print</span>(<span class="st">&#39;  Batch {:&gt;5,}  of  {:&gt;5,}.&#39;</span>.<span class="bu">format</span>(step, <span class="bu">len</span>(dataloader)))</a>
<a class="sourceLine" id="cb38-26" title="26"></a>
<a class="sourceLine" id="cb38-27" title="27">        <span class="co"># Unpack this training batch from our dataloader:</span></a>
<a class="sourceLine" id="cb38-28" title="28">        <span class="co">#</span></a>
<a class="sourceLine" id="cb38-29" title="29">        <span class="co"># As we unpack the batch, we&#39;ll also copy each tensor to the GPU</span></a>
<a class="sourceLine" id="cb38-30" title="30">        <span class="co">#</span></a>
<a class="sourceLine" id="cb38-31" title="31">        <span class="co"># `batch` contains two pytorch tensors:</span></a>
<a class="sourceLine" id="cb38-32" title="32">        <span class="co">#   [0]: input ids</span></a>
<a class="sourceLine" id="cb38-33" title="33">        <span class="co">#   [1]: labels</span></a>
<a class="sourceLine" id="cb38-34" title="34">        b_input_ids <span class="op">=</span> batch[<span class="dv">0</span>].cuda()</a>
<a class="sourceLine" id="cb38-35" title="35">        b_labels <span class="op">=</span> batch[<span class="dv">1</span>].cuda().<span class="bu">type</span>(torch.cuda.FloatTensor)</a>
<a class="sourceLine" id="cb38-36" title="36"></a>
<a class="sourceLine" id="cb38-37" title="37">        <span class="co"># clear previously calculated gradients</span></a>
<a class="sourceLine" id="cb38-38" title="38">        optimizer.zero_grad()</a>
<a class="sourceLine" id="cb38-39" title="39"></a>
<a class="sourceLine" id="cb38-40" title="40">        <span class="co"># forward propagation (evaluate model on training batch)</span></a>
<a class="sourceLine" id="cb38-41" title="41">        logits <span class="op">=</span> model(b_input_ids)</a>
<a class="sourceLine" id="cb38-42" title="42"></a>
<a class="sourceLine" id="cb38-43" title="43">        <span class="co"># calculate BCEWithLogitsLoss</span></a>
<a class="sourceLine" id="cb38-44" title="44">        loss <span class="op">=</span> criterion(logits, b_labels)</a>
<a class="sourceLine" id="cb38-45" title="45"></a>
<a class="sourceLine" id="cb38-46" title="46">        <span class="co"># sum the training loss over all batches for average loss at end</span></a>
<a class="sourceLine" id="cb38-47" title="47">        train_total_loss <span class="op">+=</span> loss.item()</a>
<a class="sourceLine" id="cb38-48" title="48"></a>
<a class="sourceLine" id="cb38-49" title="49">        <span class="co"># perform backward propagation to calculate gradients</span></a>
<a class="sourceLine" id="cb38-50" title="50">        loss.backward()</a>
<a class="sourceLine" id="cb38-51" title="51"></a>
<a class="sourceLine" id="cb38-52" title="52">        <span class="co"># clip the gradients to 1 to reduce exploding gradients</span></a>
<a class="sourceLine" id="cb38-53" title="53">        torch.nn.utils.clip_grad_norm_(model.parameters(), <span class="fl">1.0</span>)</a>
<a class="sourceLine" id="cb38-54" title="54"></a>
<a class="sourceLine" id="cb38-55" title="55">        <span class="co"># update coefficients and toward gradient</span></a>
<a class="sourceLine" id="cb38-56" title="56">        optimizer.step()</a>
<a class="sourceLine" id="cb38-57" title="57"></a>
<a class="sourceLine" id="cb38-58" title="58">        <span class="co"># update the learning rate</span></a>
<a class="sourceLine" id="cb38-59" title="59">        scheduler.step()</a>
<a class="sourceLine" id="cb38-60" title="60"></a>
<a class="sourceLine" id="cb38-61" title="61">        <span class="co"># generate predictions</span></a>
<a class="sourceLine" id="cb38-62" title="62">        rounded_preds <span class="op">=</span> torch.<span class="bu">round</span>(torch.sigmoid(logits))</a>
<a class="sourceLine" id="cb38-63" title="63"></a>
<a class="sourceLine" id="cb38-64" title="64">        <span class="co"># move logits and labels to CPU</span></a>
<a class="sourceLine" id="cb38-65" title="65">        rounded_preds <span class="op">=</span> rounded_preds.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb38-66" title="66">        y_true <span class="op">=</span> b_labels.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb38-67" title="67"></a>
<a class="sourceLine" id="cb38-68" title="68">        <span class="co"># calculate f1</span></a>
<a class="sourceLine" id="cb38-69" title="69">        total_train_f1 <span class="op">+=</span> f1_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb38-70" title="70">                                   average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb38-71" title="71">                                   labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb38-72" title="72"></a>
<a class="sourceLine" id="cb38-73" title="73">    <span class="co"># calculate the average loss over all of the batches</span></a>
<a class="sourceLine" id="cb38-74" title="74">    avg_train_loss <span class="op">=</span> train_total_loss <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb38-75" title="75"></a>
<a class="sourceLine" id="cb38-76" title="76">    <span class="co"># calculate the average f1 over all of the batches</span></a>
<a class="sourceLine" id="cb38-77" title="77">    avg_train_f1 <span class="op">=</span> total_train_f1 <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb38-78" title="78"></a>
<a class="sourceLine" id="cb38-79" title="79">    <span class="co"># Record all statistics from this epoch.</span></a>
<a class="sourceLine" id="cb38-80" title="80">    training_stats.append(</a>
<a class="sourceLine" id="cb38-81" title="81">        {</a>
<a class="sourceLine" id="cb38-82" title="82">            <span class="st">&#39;Train Loss&#39;</span>: avg_train_loss,</a>
<a class="sourceLine" id="cb38-83" title="83">            <span class="st">&#39;Train F1&#39;</span>: avg_train_f1</a>
<a class="sourceLine" id="cb38-84" title="84">        }</a>
<a class="sourceLine" id="cb38-85" title="85">    )</a>
<a class="sourceLine" id="cb38-86" title="86"></a>
<a class="sourceLine" id="cb38-87" title="87">    <span class="co"># training time end</span></a>
<a class="sourceLine" id="cb38-88" title="88">    training_time <span class="op">=</span> format_time(time.time() <span class="op">-</span> total_t0)</a>
<a class="sourceLine" id="cb38-89" title="89"></a>
<a class="sourceLine" id="cb38-90" title="90">    <span class="co"># print result summaries</span></a>
<a class="sourceLine" id="cb38-91" title="91">    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb38-92" title="92">    <span class="bu">print</span>(<span class="st">&quot;summary results&quot;</span>)</a>
<a class="sourceLine" id="cb38-93" title="93">    <span class="bu">print</span>(<span class="st">&quot;epoch | trn loss | trn f1 | trn time &quot;</span>)</a>
<a class="sourceLine" id="cb38-94" title="94">    <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">:5d}</span><span class="ss"> | </span><span class="sc">{</span>avg_train_loss<span class="sc">:.5f}</span><span class="ss"> | </span><span class="sc">{</span>avg_train_f1<span class="sc">:.5f}</span><span class="ss"> | </span><span class="sc">{</span>training_time<span class="sc">:}</span><span class="ss">&quot;</span>)</a>
<a class="sourceLine" id="cb38-95" title="95"></a>
<a class="sourceLine" id="cb38-96" title="96">    torch.cuda.empty_cache()</a>
<a class="sourceLine" id="cb38-97" title="97"></a>
<a class="sourceLine" id="cb38-98" title="98">    <span class="cf">return</span> <span class="va">None</span></a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">def</span> validating(model, dataloader, criterion):</a>
<a class="sourceLine" id="cb39-2" title="2"></a>
<a class="sourceLine" id="cb39-3" title="3">    <span class="co"># capture validation time</span></a>
<a class="sourceLine" id="cb39-4" title="4">    total_t0 <span class="op">=</span> time.time()</a>
<a class="sourceLine" id="cb39-5" title="5"></a>
<a class="sourceLine" id="cb39-6" title="6">    <span class="co"># After the completion of each training epoch, measure our performance on</span></a>
<a class="sourceLine" id="cb39-7" title="7">    <span class="co"># our validation set.</span></a>
<a class="sourceLine" id="cb39-8" title="8">    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb39-9" title="9">    <span class="bu">print</span>(<span class="st">&quot;Running Validation...&quot;</span>)</a>
<a class="sourceLine" id="cb39-10" title="10"></a>
<a class="sourceLine" id="cb39-11" title="11">    <span class="co"># put the model in evaluation mode</span></a>
<a class="sourceLine" id="cb39-12" title="12">    model.<span class="bu">eval</span>()</a>
<a class="sourceLine" id="cb39-13" title="13"></a>
<a class="sourceLine" id="cb39-14" title="14">    <span class="co"># track variables</span></a>
<a class="sourceLine" id="cb39-15" title="15">    total_valid_accuracy <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-16" title="16">    total_valid_loss <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-17" title="17">    total_valid_f1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-18" title="18">    total_valid_recall <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-19" title="19">    total_valid_precision <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-20" title="20"></a>
<a class="sourceLine" id="cb39-21" title="21">    <span class="co"># evaluate data for one epoch</span></a>
<a class="sourceLine" id="cb39-22" title="22">    <span class="cf">for</span> batch <span class="kw">in</span> dataloader:</a>
<a class="sourceLine" id="cb39-23" title="23"></a>
<a class="sourceLine" id="cb39-24" title="24">        <span class="co"># unpack batch from dataloader</span></a>
<a class="sourceLine" id="cb39-25" title="25">        b_input_ids <span class="op">=</span> batch[<span class="dv">0</span>].cuda()</a>
<a class="sourceLine" id="cb39-26" title="26">        b_labels <span class="op">=</span> batch[<span class="dv">1</span>].cuda().<span class="bu">type</span>(torch.cuda.FloatTensor)</a>
<a class="sourceLine" id="cb39-27" title="27"></a>
<a class="sourceLine" id="cb39-28" title="28">        <span class="co"># tell pytorch not to bother calculating gradients</span></a>
<a class="sourceLine" id="cb39-29" title="29">        <span class="co"># as its only necessary for training</span></a>
<a class="sourceLine" id="cb39-30" title="30">        <span class="cf">with</span> torch.no_grad():</a>
<a class="sourceLine" id="cb39-31" title="31"></a>
<a class="sourceLine" id="cb39-32" title="32">            <span class="co"># forward propagation (evaluate model on training batch)</span></a>
<a class="sourceLine" id="cb39-33" title="33">            logits <span class="op">=</span> model(b_input_ids)</a>
<a class="sourceLine" id="cb39-34" title="34"></a>
<a class="sourceLine" id="cb39-35" title="35">            <span class="co"># calculate BCEWithLogitsLoss</span></a>
<a class="sourceLine" id="cb39-36" title="36">            loss <span class="op">=</span> criterion(logits, b_labels)</a>
<a class="sourceLine" id="cb39-37" title="37"></a>
<a class="sourceLine" id="cb39-38" title="38">        <span class="co"># accumulate validation loss</span></a>
<a class="sourceLine" id="cb39-39" title="39">        total_valid_loss <span class="op">+=</span> loss.item()</a>
<a class="sourceLine" id="cb39-40" title="40"></a>
<a class="sourceLine" id="cb39-41" title="41">        <span class="co"># generate predictions</span></a>
<a class="sourceLine" id="cb39-42" title="42">        rounded_preds <span class="op">=</span> torch.<span class="bu">round</span>(torch.sigmoid(logits))</a>
<a class="sourceLine" id="cb39-43" title="43"></a>
<a class="sourceLine" id="cb39-44" title="44">        <span class="co"># move logits and labels to CPU</span></a>
<a class="sourceLine" id="cb39-45" title="45">        rounded_preds <span class="op">=</span> rounded_preds.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb39-46" title="46">        y_true <span class="op">=</span> b_labels.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb39-47" title="47"></a>
<a class="sourceLine" id="cb39-48" title="48">        <span class="co"># calculate f1</span></a>
<a class="sourceLine" id="cb39-49" title="49">        total_valid_f1 <span class="op">+=</span> f1_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb39-50" title="50">                                   average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb39-51" title="51">                                   labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb39-52" title="52"></a>
<a class="sourceLine" id="cb39-53" title="53">        <span class="co"># calculate accuracy</span></a>
<a class="sourceLine" id="cb39-54" title="54">        total_valid_accuracy <span class="op">+=</span> accuracy_score(rounded_preds, y_true)</a>
<a class="sourceLine" id="cb39-55" title="55"></a>
<a class="sourceLine" id="cb39-56" title="56">        <span class="co"># calculate precision</span></a>
<a class="sourceLine" id="cb39-57" title="57">        total_valid_precision <span class="op">+=</span> precision_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb39-58" title="58">                                                 average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb39-59" title="59">                                                 labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb39-60" title="60"></a>
<a class="sourceLine" id="cb39-61" title="61">        <span class="co"># calculate recall</span></a>
<a class="sourceLine" id="cb39-62" title="62">        total_valid_recall <span class="op">+=</span> recall_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb39-63" title="63">                                                 average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb39-64" title="64">                                                 labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb39-65" title="65"></a>
<a class="sourceLine" id="cb39-66" title="66">    <span class="co"># report final accuracy of validation run</span></a>
<a class="sourceLine" id="cb39-67" title="67">    avg_accuracy <span class="op">=</span> total_valid_accuracy <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb39-68" title="68"></a>
<a class="sourceLine" id="cb39-69" title="69">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb39-70" title="70">    <span class="kw">global</span> avg_val_f1</a>
<a class="sourceLine" id="cb39-71" title="71">    avg_val_f1 <span class="op">=</span> total_valid_f1 <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb39-72" title="72"></a>
<a class="sourceLine" id="cb39-73" title="73">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb39-74" title="74">    avg_precision <span class="op">=</span> total_valid_precision <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb39-75" title="75"></a>
<a class="sourceLine" id="cb39-76" title="76">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb39-77" title="77">    avg_recall <span class="op">=</span> total_valid_recall <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb39-78" title="78"></a>
<a class="sourceLine" id="cb39-79" title="79">    <span class="co"># calculate the average loss over all of the batches.</span></a>
<a class="sourceLine" id="cb39-80" title="80">    avg_val_loss <span class="op">=</span> total_valid_loss <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb39-81" title="81"></a>
<a class="sourceLine" id="cb39-82" title="82">    <span class="co"># Record all statistics from this epoch.</span></a>
<a class="sourceLine" id="cb39-83" title="83">    valid_stats.append(</a>
<a class="sourceLine" id="cb39-84" title="84">        {</a>
<a class="sourceLine" id="cb39-85" title="85">            <span class="st">&#39;Val Loss&#39;</span>: avg_val_loss,</a>
<a class="sourceLine" id="cb39-86" title="86">            <span class="st">&#39;Val Accur.&#39;</span>: avg_accuracy,</a>
<a class="sourceLine" id="cb39-87" title="87">            <span class="st">&#39;Val precision&#39;</span>: avg_precision,</a>
<a class="sourceLine" id="cb39-88" title="88">            <span class="st">&#39;Val recall&#39;</span>: avg_recall,</a>
<a class="sourceLine" id="cb39-89" title="89">            <span class="st">&#39;Val F1&#39;</span>: avg_val_f1</a>
<a class="sourceLine" id="cb39-90" title="90">        }</a>
<a class="sourceLine" id="cb39-91" title="91">    )</a>
<a class="sourceLine" id="cb39-92" title="92"></a>
<a class="sourceLine" id="cb39-93" title="93">    <span class="co"># capture end validation time</span></a>
<a class="sourceLine" id="cb39-94" title="94">    training_time <span class="op">=</span> format_time(time.time() <span class="op">-</span> total_t0)</a>
<a class="sourceLine" id="cb39-95" title="95"></a>
<a class="sourceLine" id="cb39-96" title="96">    <span class="co"># print result summaries</span></a>
<a class="sourceLine" id="cb39-97" title="97">    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb39-98" title="98">    <span class="bu">print</span>(<span class="st">&quot;summary results&quot;</span>)</a>
<a class="sourceLine" id="cb39-99" title="99">    <span class="bu">print</span>(<span class="st">&quot;epoch | val loss | val f1 | val time&quot;</span>)</a>
<a class="sourceLine" id="cb39-100" title="100">    <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">:5d}</span><span class="ss"> | </span><span class="sc">{</span>avg_val_loss<span class="sc">:.5f}</span><span class="ss"> | </span><span class="sc">{</span>avg_val_f1<span class="sc">:.5f}</span><span class="ss"> | </span><span class="sc">{</span>training_time<span class="sc">:}</span><span class="ss">&quot;</span>)</a>
<a class="sourceLine" id="cb39-101" title="101"></a>
<a class="sourceLine" id="cb39-102" title="102">    <span class="cf">return</span> <span class="va">None</span></a></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">def</span> testing(model, dataloader, criterion):</a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3">    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb40-4" title="4">    <span class="bu">print</span>(<span class="st">&quot;Running Testing...&quot;</span>)</a>
<a class="sourceLine" id="cb40-5" title="5"></a>
<a class="sourceLine" id="cb40-6" title="6">    <span class="co"># put the model in evaluation mode</span></a>
<a class="sourceLine" id="cb40-7" title="7">    model.<span class="bu">eval</span>()</a>
<a class="sourceLine" id="cb40-8" title="8"></a>
<a class="sourceLine" id="cb40-9" title="9">    <span class="co"># track variables</span></a>
<a class="sourceLine" id="cb40-10" title="10">    total_test_accuracy <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-11" title="11">    total_test_loss <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-12" title="12">    total_test_f1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-13" title="13">    total_test_recall <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-14" title="14">    total_test_precision <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb40-15" title="15"></a>
<a class="sourceLine" id="cb40-16" title="16">    <span class="co"># evaluate data for one epoch</span></a>
<a class="sourceLine" id="cb40-17" title="17">    <span class="cf">for</span> step, batch <span class="kw">in</span> <span class="bu">enumerate</span>(dataloader):</a>
<a class="sourceLine" id="cb40-18" title="18">        <span class="co"># progress update every 40 batches.</span></a>
<a class="sourceLine" id="cb40-19" title="19">        <span class="cf">if</span> step <span class="op">%</span> <span class="dv">40</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> <span class="kw">not</span> step <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb40-20" title="20"></a>
<a class="sourceLine" id="cb40-21" title="21">            <span class="co"># Report progress.</span></a>
<a class="sourceLine" id="cb40-22" title="22">            <span class="bu">print</span>(<span class="st">&#39;  Batch {:&gt;5,}  of  {:&gt;5,}.&#39;</span>.<span class="bu">format</span>(step, <span class="bu">len</span>(dataloader)))</a>
<a class="sourceLine" id="cb40-23" title="23"></a>
<a class="sourceLine" id="cb40-24" title="24">        <span class="co"># unpack batch from dataloader</span></a>
<a class="sourceLine" id="cb40-25" title="25">        b_input_ids <span class="op">=</span> batch[<span class="dv">0</span>].cuda()</a>
<a class="sourceLine" id="cb40-26" title="26">        b_labels <span class="op">=</span> batch[<span class="dv">1</span>].cuda().<span class="bu">type</span>(torch.cuda.FloatTensor)</a>
<a class="sourceLine" id="cb40-27" title="27"></a>
<a class="sourceLine" id="cb40-28" title="28">        <span class="co"># tell pytorch not to bother calculating gradients</span></a>
<a class="sourceLine" id="cb40-29" title="29">        <span class="co"># only necessary for training</span></a>
<a class="sourceLine" id="cb40-30" title="30">        <span class="cf">with</span> torch.no_grad():</a>
<a class="sourceLine" id="cb40-31" title="31"></a>
<a class="sourceLine" id="cb40-32" title="32">            <span class="co"># forward propagation (evaluate model on training batch)</span></a>
<a class="sourceLine" id="cb40-33" title="33">            logits <span class="op">=</span> model(b_input_ids)</a>
<a class="sourceLine" id="cb40-34" title="34"></a>
<a class="sourceLine" id="cb40-35" title="35">            <span class="co"># calculate BCEWithLogitsLoss</span></a>
<a class="sourceLine" id="cb40-36" title="36">            loss <span class="op">=</span> criterion(logits, b_labels)</a>
<a class="sourceLine" id="cb40-37" title="37"></a>
<a class="sourceLine" id="cb40-38" title="38">            <span class="co"># accumulate validation loss</span></a>
<a class="sourceLine" id="cb40-39" title="39">            total_test_loss <span class="op">+=</span> loss.item()</a>
<a class="sourceLine" id="cb40-40" title="40"></a>
<a class="sourceLine" id="cb40-41" title="41">            <span class="co"># generate predictions</span></a>
<a class="sourceLine" id="cb40-42" title="42">            rounded_preds <span class="op">=</span> torch.<span class="bu">round</span>(torch.sigmoid(logits))</a>
<a class="sourceLine" id="cb40-43" title="43"></a>
<a class="sourceLine" id="cb40-44" title="44">            <span class="co"># move logits and labels to CPU</span></a>
<a class="sourceLine" id="cb40-45" title="45">            rounded_preds <span class="op">=</span> rounded_preds.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb40-46" title="46">            y_true <span class="op">=</span> b_labels.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb40-47" title="47"></a>
<a class="sourceLine" id="cb40-48" title="48">            <span class="co"># calculate f1</span></a>
<a class="sourceLine" id="cb40-49" title="49">            total_test_f1 <span class="op">+=</span> f1_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb40-50" title="50">                                       average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb40-51" title="51">                                       labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb40-52" title="52"></a>
<a class="sourceLine" id="cb40-53" title="53">            <span class="co"># calculate accuracy</span></a>
<a class="sourceLine" id="cb40-54" title="54">            total_test_accuracy <span class="op">+=</span> accuracy_score(rounded_preds, y_true)</a>
<a class="sourceLine" id="cb40-55" title="55"></a>
<a class="sourceLine" id="cb40-56" title="56">            <span class="co"># calculate precision</span></a>
<a class="sourceLine" id="cb40-57" title="57">            total_test_precision <span class="op">+=</span> precision_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb40-58" title="58">                                                     average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb40-59" title="59">                                                     labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb40-60" title="60"></a>
<a class="sourceLine" id="cb40-61" title="61">            <span class="co"># calculate recall</span></a>
<a class="sourceLine" id="cb40-62" title="62">            total_test_recall <span class="op">+=</span> recall_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb40-63" title="63">                                                     average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb40-64" title="64">                                                     labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb40-65" title="65"></a>
<a class="sourceLine" id="cb40-66" title="66">    <span class="co"># report final accuracy of validation run</span></a>
<a class="sourceLine" id="cb40-67" title="67">    avg_accuracy <span class="op">=</span> total_test_accuracy <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb40-68" title="68"></a>
<a class="sourceLine" id="cb40-69" title="69">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb40-70" title="70">    avg_test_f1 <span class="op">=</span> total_test_f1 <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb40-71" title="71"></a>
<a class="sourceLine" id="cb40-72" title="72">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb40-73" title="73">    avg_precision <span class="op">=</span> total_test_precision <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb40-74" title="74"></a>
<a class="sourceLine" id="cb40-75" title="75">    <span class="co"># report final f1 of validation run</span></a>
<a class="sourceLine" id="cb40-76" title="76">    avg_recall <span class="op">=</span> total_test_recall <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb40-77" title="77"></a>
<a class="sourceLine" id="cb40-78" title="78">    <span class="co"># calculate the average loss over all of the batches.</span></a>
<a class="sourceLine" id="cb40-79" title="79">    avg_test_loss <span class="op">=</span> total_test_loss <span class="op">/</span> <span class="bu">len</span>(dataloader)</a>
<a class="sourceLine" id="cb40-80" title="80"></a>
<a class="sourceLine" id="cb40-81" title="81">    <span class="co"># Record all statistics from this epoch.</span></a>
<a class="sourceLine" id="cb40-82" title="82">    test_stats.append(</a>
<a class="sourceLine" id="cb40-83" title="83">        {</a>
<a class="sourceLine" id="cb40-84" title="84">            <span class="st">&#39;Test Loss&#39;</span>: avg_test_loss,</a>
<a class="sourceLine" id="cb40-85" title="85">            <span class="st">&#39;Test Accur.&#39;</span>: avg_accuracy,</a>
<a class="sourceLine" id="cb40-86" title="86">            <span class="st">&#39;Test precision&#39;</span>: avg_precision,</a>
<a class="sourceLine" id="cb40-87" title="87">            <span class="st">&#39;Test recall&#39;</span>: avg_recall,</a>
<a class="sourceLine" id="cb40-88" title="88">            <span class="st">&#39;Test F1&#39;</span>: avg_test_f1</a>
<a class="sourceLine" id="cb40-89" title="89">        }</a>
<a class="sourceLine" id="cb40-90" title="90">    )</a>
<a class="sourceLine" id="cb40-91" title="91">    <span class="cf">return</span> <span class="va">None</span></a></code></pre></div>
<p>In order to use our CNN, we need to specify a config class that sets a number of hyperparameters that the class is expecting.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb41-1" title="1"><span class="co"># instantiate model config -- set ex-post from optuna search</span></a>
<a class="sourceLine" id="cb41-2" title="2"><span class="kw">class</span> config:</a>
<a class="sourceLine" id="cb41-3" title="3">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb41-4" title="4">        config.pre_embed <span class="op">=</span> embeddings_tensor  <span class="co"># GloVe vectors</span></a>
<a class="sourceLine" id="cb41-5" title="5">        config.mode <span class="op">=</span> <span class="st">&#39;static&#39;</span>  <span class="co"># dont train embedding</span></a>
<a class="sourceLine" id="cb41-6" title="6">        config.num_classes <span class="op">=</span> <span class="dv">1</span>  <span class="co"># binary</span></a>
<a class="sourceLine" id="cb41-7" title="7">        config.output_channel <span class="op">=</span> <span class="dv">1450</span>  <span class="co"># number of kernels</span></a>
<a class="sourceLine" id="cb41-8" title="8">        config.embedding_dim <span class="op">=</span> <span class="dv">201</span>  <span class="co"># GloVe embed dimension (202)</span></a>
<a class="sourceLine" id="cb41-9" title="9">        config.vocab_size <span class="op">=</span> <span class="bu">len</span>(vocab)<span class="op">+</span><span class="dv">2</span>  <span class="co"># vocab size of corpus plus unknown/padding</span></a>
<a class="sourceLine" id="cb41-10" title="10">        config.dropout <span class="op">=</span> <span class="fl">0.1</span>  <span class="co"># dropout value</span></a>
<a class="sourceLine" id="cb41-11" title="11">        config.padding_idx <span class="op">=</span> <span class="dv">400001</span>  <span class="co"># padding token index</span></a>
<a class="sourceLine" id="cb41-12" title="12">        <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb41-13" title="13"></a>
<a class="sourceLine" id="cb41-14" title="14"><span class="co"># create config</span></a>
<a class="sourceLine" id="cb41-15" title="15">config1 <span class="op">=</span> config()</a>
<a class="sourceLine" id="cb41-16" title="16"></a>
<a class="sourceLine" id="cb41-17" title="17"><span class="co"># instantiate model - attach to GPU</span></a>
<a class="sourceLine" id="cb41-18" title="18">model <span class="op">=</span> KimCNN(config1).cuda()</a></code></pre></div>
<p>Now we are almost ready to train. A few other preparatory objects are created like the loss criteria, epochs, the optimizer, and our optimizer scheduler.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb42-1" title="1"><span class="co"># set loss</span></a>
<a class="sourceLine" id="cb42-2" title="2">criterion <span class="op">=</span> nn.BCEWithLogitsLoss()</a>
<a class="sourceLine" id="cb42-3" title="3"></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="co"># set number of epochs</span></a>
<a class="sourceLine" id="cb42-5" title="5">epochs <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7"><span class="co"># set optimizer</span></a>
<a class="sourceLine" id="cb42-8" title="8">optimizer <span class="op">=</span> AdamW(model.parameters(),</a>
<a class="sourceLine" id="cb42-9" title="9">                  lr<span class="op">=</span><span class="fl">0.000147</span>,</a>
<a class="sourceLine" id="cb42-10" title="10">                  weight_decay<span class="op">=</span><span class="fl">0.65</span></a>
<a class="sourceLine" id="cb42-11" title="11">                )</a>
<a class="sourceLine" id="cb42-12" title="12"></a>
<a class="sourceLine" id="cb42-13" title="13"><span class="co"># set LR scheduler</span></a>
<a class="sourceLine" id="cb42-14" title="14">total_steps <span class="op">=</span> <span class="bu">len</span>(train_dataloader) <span class="op">*</span> epochs</a>
<a class="sourceLine" id="cb42-15" title="15">scheduler <span class="op">=</span> get_linear_schedule_with_warmup(optimizer,</a>
<a class="sourceLine" id="cb42-16" title="16">                                            num_warmup_steps<span class="op">=</span><span class="dv">0</span>,</a>
<a class="sourceLine" id="cb42-17" title="17">                                            num_training_steps<span class="op">=</span>total_steps)</a></code></pre></div>
<p>Finally we are ready to train. Two containers are created to store the results of each training and validation epoch</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb43-1" title="1"><span class="co"># create training result storage</span></a>
<a class="sourceLine" id="cb43-2" title="2">training_stats <span class="op">=</span> []</a>
<a class="sourceLine" id="cb43-3" title="3">valid_stats <span class="op">=</span> []</a>
<a class="sourceLine" id="cb43-4" title="4">best_valid_loss <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</a>
<a class="sourceLine" id="cb43-5" title="5"></a>
<a class="sourceLine" id="cb43-6" title="6"><span class="co"># for each epoch</span></a>
<a class="sourceLine" id="cb43-7" title="7"><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</a>
<a class="sourceLine" id="cb43-8" title="8">    <span class="co"># train</span></a>
<a class="sourceLine" id="cb43-9" title="9">    train(model, train_dataloader, optimizer, criterion)</a>
<a class="sourceLine" id="cb43-10" title="10">    <span class="co"># validate</span></a>
<a class="sourceLine" id="cb43-11" title="11">    validating(model, valid_dataloader, criterion)</a>
<a class="sourceLine" id="cb43-12" title="12">    <span class="co"># check validation loss</span></a>
<a class="sourceLine" id="cb43-13" title="13">    <span class="cf">if</span> valid_stats[epoch][<span class="st">&#39;Val Loss&#39;</span>] <span class="op">&lt;</span> best_valid_loss:</a>
<a class="sourceLine" id="cb43-14" title="14">        best_valid_loss <span class="op">=</span> valid_stats[epoch][<span class="st">&#39;Val Loss&#39;</span>]</a>
<a class="sourceLine" id="cb43-15" title="15">        <span class="co"># save best model for use later</span></a>
<a class="sourceLine" id="cb43-16" title="16">        torch.save(model.state_dict(), <span class="st">&#39;cnn-model1.pt&#39;</span>)</a></code></pre></div>
<pre><code>## 
## ======== Epoch 1 / 5 ========
## Training...
##   Batch    40  of    101.
##   Batch    80  of    101.
## 
## summary results
## epoch | trn loss | trn f1 | trn time 
##     1 | 0.40701 | 0.83158 | 0:00:33
## 
## Running Validation...
## 
## summary results
## epoch | val loss | val f1 | val time
##     1 | 0.34267 | 0.83920 | 0:00:02
## 
## ======== Epoch 2 / 5 ========
## Training...
##   Batch    40  of    101.
##   Batch    80  of    101.
## 
## summary results
## epoch | trn loss | trn f1 | trn time 
##     2 | 0.30050 | 0.87663 | 0:00:31
## 
## Running Validation...
## 
## summary results
## epoch | val loss | val f1 | val time
##     2 | 0.27802 | 0.86507 | 0:00:02
## 
## ======== Epoch 3 / 5 ========
## Training...
##   Batch    40  of    101.
##   Batch    80  of    101.
## 
## summary results
## epoch | trn loss | trn f1 | trn time 
##     3 | 0.26926 | 0.89293 | 0:00:31
## 
## Running Validation...
## 
## summary results
## epoch | val loss | val f1 | val time
##     3 | 0.29514 | 0.85815 | 0:00:02
## 
## ======== Epoch 4 / 5 ========
## Training...
##   Batch    40  of    101.
##   Batch    80  of    101.
## 
## summary results
## epoch | trn loss | trn f1 | trn time 
##     4 | 0.24897 | 0.89783 | 0:00:31
## 
## Running Validation...
## 
## summary results
## epoch | val loss | val f1 | val time
##     4 | 0.28200 | 0.86853 | 0:00:02
## 
## ======== Epoch 5 / 5 ========
## Training...
##   Batch    40  of    101.
##   Batch    80  of    101.
## 
## summary results
## epoch | trn loss | trn f1 | trn time 
##     5 | 0.22324 | 0.91354 | 0:00:33
## 
## Running Validation...
## 
## summary results
## epoch | val loss | val f1 | val time
##     5 | 0.29347 | 0.86368 | 0:00:02</code></pre>
<p>After training, we organize the results nicely in <code>pandas</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb45-1" title="1"><span class="co"># organize results</span></a>
<a class="sourceLine" id="cb45-2" title="2">pd.set_option(<span class="st">&#39;precision&#39;</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb45-3" title="3">df_train_stats <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>training_stats)</a>
<a class="sourceLine" id="cb45-4" title="4">df_valid_stats <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>valid_stats)</a>
<a class="sourceLine" id="cb45-5" title="5">df_stats <span class="op">=</span> pd.concat([df_train_stats, df_valid_stats], axis<span class="op">=</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb45-6" title="6">df_stats.insert(<span class="dv">0</span>, <span class="st">&#39;Epoch&#39;</span>, <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(df_stats)<span class="op">+</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb45-7" title="7">df_stats <span class="op">=</span> df_stats.set_index(<span class="st">&#39;Epoch&#39;</span>)</a>
<a class="sourceLine" id="cb45-8" title="8">df_stats</a></code></pre></div>
<pre><code>##        Train Loss  Train F1  Val Loss  ...  Val precision  Val recall  Val F1
## Epoch                                  ...                                   
## 1           0.407     0.832     0.343  ...          0.854       0.847   0.839
## 2           0.300     0.877     0.278  ...          0.873       0.870   0.865
## 3           0.269     0.893     0.295  ...          0.871       0.865   0.858
## 4           0.249     0.898     0.282  ...          0.879       0.875   0.869
## 5           0.223     0.914     0.293  ...          0.877       0.870   0.864
## 
## [5 rows x 7 columns]</code></pre>
<p>Then we plot our results like so:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">def</span> plot_results(df):</a>
<a class="sourceLine" id="cb47-2" title="2">    <span class="co"># styling from seaborn.</span></a>
<a class="sourceLine" id="cb47-3" title="3">    sns.<span class="bu">set</span>(style<span class="op">=</span><span class="st">&#39;darkgrid&#39;</span>)</a>
<a class="sourceLine" id="cb47-4" title="4">    <span class="co"># uncrease the plot size and font size.</span></a>
<a class="sourceLine" id="cb47-5" title="5">    sns.<span class="bu">set</span>(font_scale<span class="op">=</span><span class="fl">1.5</span>)</a>
<a class="sourceLine" id="cb47-6" title="6">    plt.rcParams[<span class="st">&quot;figure.figsize&quot;</span>] <span class="op">=</span> (<span class="dv">12</span>,<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb47-7" title="7"></a>
<a class="sourceLine" id="cb47-8" title="8">    <span class="co"># plot the learning curve.</span></a>
<a class="sourceLine" id="cb47-9" title="9">    plt.plot(df_stats[<span class="st">&#39;Train Loss&#39;</span>], <span class="st">&#39;b-o&#39;</span>, label<span class="op">=</span><span class="st">&quot;Training&quot;</span>)</a>
<a class="sourceLine" id="cb47-10" title="10">    plt.plot(df_stats[<span class="st">&#39;Val Loss&#39;</span>], <span class="st">&#39;g-o&#39;</span>, label<span class="op">=</span><span class="st">&quot;Validation&quot;</span>)</a>
<a class="sourceLine" id="cb47-11" title="11"></a>
<a class="sourceLine" id="cb47-12" title="12">    <span class="co"># Label the plot.</span></a>
<a class="sourceLine" id="cb47-13" title="13">    plt.title(<span class="st">&quot;Training &amp; Validation Loss&quot;</span>)</a>
<a class="sourceLine" id="cb47-14" title="14">    plt.xlabel(<span class="st">&quot;Epoch&quot;</span>)</a>
<a class="sourceLine" id="cb47-15" title="15">    plt.ylabel(<span class="st">&quot;Loss&quot;</span>)</a>
<a class="sourceLine" id="cb47-16" title="16">    plt.legend()</a>
<a class="sourceLine" id="cb47-17" title="17">    plt.xticks([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a>
<a class="sourceLine" id="cb47-18" title="18">    <span class="cf">return</span> plt.show()</a>
<a class="sourceLine" id="cb47-19" title="19"></a>
<a class="sourceLine" id="cb47-20" title="20"></a>
<a class="sourceLine" id="cb47-21" title="21">plot_results(df_stats)</a></code></pre></div>
<div class="figure">
<img src="data:image/png;base64,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" alt="Training Results" style="width:75.0%" />
<p class="caption">Training Results</p>
</div>
<p>And lastly run our final test:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb48-1" title="1"><span class="co"># test the model</span></a>
<a class="sourceLine" id="cb48-2" title="2">test_stats <span class="op">=</span> []</a>
<a class="sourceLine" id="cb48-3" title="3">model.load_state_dict(torch.load(<span class="st">&#39;cnn-model1.pt&#39;</span>))</a></code></pre></div>
<pre><code>## &lt;All keys matched successfully&gt;</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb50-1" title="1">testing(model, test_dataloader, criterion)</a></code></pre></div>
<pre><code>## 
## Running Testing...</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb52-1" title="1">df_test_stats <span class="op">=</span> pd.DataFrame(data<span class="op">=</span>test_stats)</a>
<a class="sourceLine" id="cb52-2" title="2">df_test_stats</a></code></pre></div>
<pre><code>##    Test Loss  Test Accur.  Test precision  Test recall  Test F1
## 0      0.292        0.854           0.857        0.854    0.849</code></pre>
<p>Pretty good results for a novel data set made from scratch with an “outdated” model.</p>
</div>
<div id="cnn-inference" class="section level1">
<h1><span class="header-section-number">4</span> CNN: Inference</h1>
<p>There are some other tasks that might want to do like inference which is using what we know to predict what we do not. So let’s say that we have two new messages but no labels (see below). We can tokenize these strings like all of our other data and generate on-the-fly predictions about their inferred label.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb54-1" title="1"><span class="co"># inference</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="kw">def</span> infer_class(model, string_df, min_len<span class="op">=</span>percentile_95):</a>
<a class="sourceLine" id="cb54-3" title="3">    <span class="co"># tokenize the string into GloVe</span></a>
<a class="sourceLine" id="cb54-4" title="4">    no_matches, glove_tokenized_data <span class="op">=</span> text_to_GloVe_tokens(string_df, embeddings_dictionary)</a>
<a class="sourceLine" id="cb54-5" title="5">    <span class="co"># check length</span></a>
<a class="sourceLine" id="cb54-6" title="6">    <span class="cf">if</span> <span class="bu">len</span>(glove_tokenized_data[<span class="dv">0</span>]) <span class="op">&lt;</span> min_len:</a>
<a class="sourceLine" id="cb54-7" title="7">        glove_tokenized_data <span class="op">=</span> pad_GloVe(glove_tokenized_data, percentile_95)</a>
<a class="sourceLine" id="cb54-8" title="8">    tensor <span class="op">=</span> torch.LongTensor(glove_tokenized_data[<span class="dv">0</span>]).cuda()</a>
<a class="sourceLine" id="cb54-9" title="9">    tensor <span class="op">=</span> tensor.unsqueeze(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb54-10" title="10">    logits <span class="op">=</span> model(tensor)</a>
<a class="sourceLine" id="cb54-11" title="11">    rounded_preds <span class="op">=</span> torch.<span class="bu">round</span>(torch.sigmoid(logits))</a>
<a class="sourceLine" id="cb54-12" title="12">    <span class="cf">return</span> <span class="bu">print</span>(rounded_preds.item())</a></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb55-1" title="1">str_US <span class="op">=</span> [<span class="st">&#39;You will no longer be sent to an eternal war, President Donald Trump told a gathering marking the graduation of the US military academy. You will no longer fight in countries whose names are not known to most Americans. You will no longer be involved in the wars of the ancient nations. Clearly, Trump is referring to the long-running war in Afghanistan. The United States has been fighting the for the past two decades; it suffered a high number of casualties along with enormous financial losses. Many times, senior US officials have acknowledged that they cannot win the war in Afghanistan. Trump has told the truth, that his troops will no longer be involved in the wars of the ancient nations, because the never-ending war in Afghanistan has severely damaged America is reputation on the international level and caused the country extreme economic hardships. Recent surveys show that the support in the United States for this lost war has plummeted, and the people have now realized that the American leaders made false promises about this war. Nearly 20 years ago, the founder of the Islamic Emirate, the late Amir al- Mu aminin Mullah Mohammad Omar, warned the Americans to give up the intention of occupying Afghanistan.&#39;</span>]</a>
<a class="sourceLine" id="cb55-2" title="2"></a>
<a class="sourceLine" id="cb55-3" title="3">str_AF <span class="op">=</span> [<span class="st">&#39;On 15 June, the soldiers of the puppet regime came to carry out operations in Sheikhano area , Tagab District, Kapisa Province. The mujahideen retaliated severely: 17 offensive soldiers of the puppet were killed in the operation; many of their corpses are lying on the battlefield; and many others were wounded.&#39;</span>]</a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5"></a>
<a class="sourceLine" id="cb55-6" title="6">temp_df_US <span class="op">=</span> pd.DataFrame({<span class="st">&#39;body&#39;</span>: str_US})</a>
<a class="sourceLine" id="cb55-7" title="7">temp_df_US <span class="op">=</span> clean_df(temp_df_US)</a>
<a class="sourceLine" id="cb55-8" title="8"><span class="bu">print</span>(infer_class(model, temp_df_US))  <span class="co"># 1 = US = Correct</span></a></code></pre></div>
<pre><code>## 1.0
## None</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb57-1" title="1">temp_df_AF <span class="op">=</span> pd.DataFrame({<span class="st">&#39;body&#39;</span>: str_AF})</a>
<a class="sourceLine" id="cb57-2" title="2">temp_df_AF <span class="op">=</span> clean_df(temp_df_AF)</a>
<a class="sourceLine" id="cb57-3" title="3"><span class="bu">print</span>(infer_class(model, temp_df_AF))  <span class="co"># 0 = Kabul = Correct</span></a></code></pre></div>
<pre><code>## 0.0
## None</code></pre>
</div>
<div id="cnn-hyperband-and-asha-hyperparameter-search-with-optuna" class="section level1">
<h1><span class="header-section-number">5</span> CNN: Hyperband and ASHA Hyperparameter Search with Optuna</h1>
<p>The code below shows how we can use state-of-the-art pruning and search algorithms to improve our model’s performance through hyperparameter selection.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb59-1" title="1"><span class="co"># optuna -- tune hyperparameters</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="co"># create gradient scaler for mixed precision</span></a>
<a class="sourceLine" id="cb59-3" title="3">scaler <span class="op">=</span> GradScaler()</a>
<a class="sourceLine" id="cb59-4" title="4"></a>
<a class="sourceLine" id="cb59-5" title="5">training_stats <span class="op">=</span> []</a>
<a class="sourceLine" id="cb59-6" title="6">valid_stats <span class="op">=</span> []</a>
<a class="sourceLine" id="cb59-7" title="7">epochs <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb59-8" title="8"><span class="kw">def</span> objective(trial):</a>
<a class="sourceLine" id="cb59-9" title="9"></a>
<a class="sourceLine" id="cb59-10" title="10">    <span class="co"># alter hyperparameters</span></a>
<a class="sourceLine" id="cb59-11" title="11">    kernel_num <span class="op">=</span> trial.suggest_int(<span class="st">&#39;output_channel&#39;</span>, low<span class="op">=</span><span class="dv">600</span>, high<span class="op">=</span><span class="dv">1500</span>, step<span class="op">=</span><span class="dv">50</span>)</a>
<a class="sourceLine" id="cb59-12" title="12">    dropout_num <span class="op">=</span> trial.suggest_float(<span class="st">&#39;dropout&#39;</span>, low<span class="op">=</span><span class="fl">0.1</span>, high<span class="op">=</span><span class="fl">0.5</span>, step<span class="op">=</span><span class="fl">0.05</span>)</a>
<a class="sourceLine" id="cb59-13" title="13">    learning_rate <span class="op">=</span> trial.suggest_loguniform(<span class="st">&#39;lr&#39;</span>, <span class="fl">1e-5</span>, <span class="fl">1e-3</span>)</a>
<a class="sourceLine" id="cb59-14" title="14">    config1 <span class="op">=</span> config()</a>
<a class="sourceLine" id="cb59-15" title="15">    config1.output_channel <span class="op">=</span> kernel_num</a>
<a class="sourceLine" id="cb59-16" title="16">    config1.dropout <span class="op">=</span> dropout_num</a>
<a class="sourceLine" id="cb59-17" title="17"></a>
<a class="sourceLine" id="cb59-18" title="18">    <span class="co"># data loaders</span></a>
<a class="sourceLine" id="cb59-19" title="19">    train_dataloader <span class="op">=</span> DataLoader(train_dataset,</a>
<a class="sourceLine" id="cb59-20" title="20">                                  batch_size<span class="op">=</span><span class="dv">80</span>,</a>
<a class="sourceLine" id="cb59-21" title="21">                                  sampler<span class="op">=</span>train_sampler,</a>
<a class="sourceLine" id="cb59-22" title="22">                                  shuffle<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb59-23" title="23"></a>
<a class="sourceLine" id="cb59-24" title="24">    valid_dataloader <span class="op">=</span> DataLoader(val_dataset,</a>
<a class="sourceLine" id="cb59-25" title="25">                                  batch_size<span class="op">=</span><span class="dv">80</span>,</a>
<a class="sourceLine" id="cb59-26" title="26">                                  shuffle<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb59-27" title="27"></a>
<a class="sourceLine" id="cb59-28" title="28">    <span class="co"># instantiate model</span></a>
<a class="sourceLine" id="cb59-29" title="29">    model <span class="op">=</span> KimCNN(config1).cuda()</a>
<a class="sourceLine" id="cb59-30" title="30">    <span class="co"># set optimizer</span></a>
<a class="sourceLine" id="cb59-31" title="31">    optimizer <span class="op">=</span> AdamW(model.parameters(),</a>
<a class="sourceLine" id="cb59-32" title="32">                      lr<span class="op">=</span>learning_rate)</a>
<a class="sourceLine" id="cb59-33" title="33"></a>
<a class="sourceLine" id="cb59-34" title="34">    criterion <span class="op">=</span> nn.BCEWithLogitsLoss()</a>
<a class="sourceLine" id="cb59-35" title="35"></a>
<a class="sourceLine" id="cb59-36" title="36">    <span class="co"># set LR scheduler</span></a>
<a class="sourceLine" id="cb59-37" title="37">    total_steps <span class="op">=</span> <span class="bu">len</span>(train_dataloader) <span class="op">*</span> epochs</a>
<a class="sourceLine" id="cb59-38" title="38">    <span class="kw">global</span> scheduler</a>
<a class="sourceLine" id="cb59-39" title="39">    scheduler <span class="op">=</span> get_linear_schedule_with_warmup(optimizer,</a>
<a class="sourceLine" id="cb59-40" title="40">                                                num_warmup_steps<span class="op">=</span><span class="dv">0</span>,</a>
<a class="sourceLine" id="cb59-41" title="41">                                                num_training_steps<span class="op">=</span>total_steps)</a>
<a class="sourceLine" id="cb59-42" title="42"></a>
<a class="sourceLine" id="cb59-43" title="43">    <span class="kw">global</span> epoch</a>
<a class="sourceLine" id="cb59-44" title="44">    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</a>
<a class="sourceLine" id="cb59-45" title="45">        <span class="co"># set containers</span></a>
<a class="sourceLine" id="cb59-46" title="46">        train_total_loss <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-47" title="47">        total_train_f1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-48" title="48"></a>
<a class="sourceLine" id="cb59-49" title="49">        <span class="co"># put model into traning mode</span></a>
<a class="sourceLine" id="cb59-50" title="50">        model.train()</a>
<a class="sourceLine" id="cb59-51" title="51"></a>
<a class="sourceLine" id="cb59-52" title="52">        <span class="co"># for each batch of training data...</span></a>
<a class="sourceLine" id="cb59-53" title="53">        <span class="cf">for</span> step, batch <span class="kw">in</span> <span class="bu">enumerate</span>(train_dataloader):</a>
<a class="sourceLine" id="cb59-54" title="54">            b_input_ids <span class="op">=</span> batch[<span class="dv">0</span>].cuda()</a>
<a class="sourceLine" id="cb59-55" title="55">            b_labels <span class="op">=</span> batch[<span class="dv">1</span>].cuda().<span class="bu">type</span>(torch.cuda.FloatTensor)</a>
<a class="sourceLine" id="cb59-56" title="56"></a>
<a class="sourceLine" id="cb59-57" title="57">            optimizer.zero_grad()</a>
<a class="sourceLine" id="cb59-58" title="58"></a>
<a class="sourceLine" id="cb59-59" title="59">            <span class="cf">with</span> autocast():</a>
<a class="sourceLine" id="cb59-60" title="60">                logits <span class="op">=</span> model(b_input_ids)</a>
<a class="sourceLine" id="cb59-61" title="61">                loss <span class="op">=</span> criterion(logits, b_labels)</a>
<a class="sourceLine" id="cb59-62" title="62"></a>
<a class="sourceLine" id="cb59-63" title="63">            train_total_loss <span class="op">+=</span> loss.item()</a>
<a class="sourceLine" id="cb59-64" title="64"></a>
<a class="sourceLine" id="cb59-65" title="65">            scaler.scale(loss).backward()</a>
<a class="sourceLine" id="cb59-66" title="66">            scaler.step(optimizer)</a>
<a class="sourceLine" id="cb59-67" title="67">            scaler.update()</a>
<a class="sourceLine" id="cb59-68" title="68">            scheduler.step()</a>
<a class="sourceLine" id="cb59-69" title="69"></a>
<a class="sourceLine" id="cb59-70" title="70">        <span class="co"># validation</span></a>
<a class="sourceLine" id="cb59-71" title="71">        model.<span class="bu">eval</span>()</a>
<a class="sourceLine" id="cb59-72" title="72"></a>
<a class="sourceLine" id="cb59-73" title="73">        total_valid_loss <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-74" title="74">        total_valid_f1 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb59-75" title="75"></a>
<a class="sourceLine" id="cb59-76" title="76">        <span class="co"># evaluate data for one epoch</span></a>
<a class="sourceLine" id="cb59-77" title="77">        <span class="cf">for</span> batch <span class="kw">in</span> valid_dataloader:</a>
<a class="sourceLine" id="cb59-78" title="78"></a>
<a class="sourceLine" id="cb59-79" title="79">            b_input_ids <span class="op">=</span> batch[<span class="dv">0</span>].cuda()</a>
<a class="sourceLine" id="cb59-80" title="80">            b_labels <span class="op">=</span> batch[<span class="dv">1</span>].cuda().<span class="bu">type</span>(torch.cuda.FloatTensor)</a>
<a class="sourceLine" id="cb59-81" title="81"></a>
<a class="sourceLine" id="cb59-82" title="82">            <span class="cf">with</span> torch.no_grad():</a>
<a class="sourceLine" id="cb59-83" title="83">                logits <span class="op">=</span> model(b_input_ids)</a>
<a class="sourceLine" id="cb59-84" title="84">                loss <span class="op">=</span> criterion(logits, b_labels)</a>
<a class="sourceLine" id="cb59-85" title="85"></a>
<a class="sourceLine" id="cb59-86" title="86">            total_valid_loss <span class="op">+=</span> loss.item()</a>
<a class="sourceLine" id="cb59-87" title="87"></a>
<a class="sourceLine" id="cb59-88" title="88">        <span class="co"># generate predictions</span></a>
<a class="sourceLine" id="cb59-89" title="89">        rounded_preds <span class="op">=</span> torch.<span class="bu">round</span>(torch.sigmoid(logits))</a>
<a class="sourceLine" id="cb59-90" title="90"></a>
<a class="sourceLine" id="cb59-91" title="91">        <span class="co"># move logits and labels to CPU</span></a>
<a class="sourceLine" id="cb59-92" title="92">        rounded_preds <span class="op">=</span> rounded_preds.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb59-93" title="93">        y_true <span class="op">=</span> b_labels.detach().cpu().numpy()</a>
<a class="sourceLine" id="cb59-94" title="94"></a>
<a class="sourceLine" id="cb59-95" title="95">        <span class="co"># calculate f1</span></a>
<a class="sourceLine" id="cb59-96" title="96">        total_valid_f1 <span class="op">+=</span> f1_score(rounded_preds, y_true,</a>
<a class="sourceLine" id="cb59-97" title="97">                                   average<span class="op">=</span><span class="st">&#39;weighted&#39;</span>,</a>
<a class="sourceLine" id="cb59-98" title="98">                                   labels<span class="op">=</span>np.unique(rounded_preds))</a>
<a class="sourceLine" id="cb59-99" title="99"></a>
<a class="sourceLine" id="cb59-100" title="100">        avg_val_f1 <span class="op">=</span> total_valid_f1 <span class="op">/</span> <span class="bu">len</span>(valid_dataloader)</a>
<a class="sourceLine" id="cb59-101" title="101"></a>
<a class="sourceLine" id="cb59-102" title="102">        avg_val_loss <span class="op">=</span> total_valid_loss <span class="op">/</span> <span class="bu">len</span>(valid_dataloader)</a>
<a class="sourceLine" id="cb59-103" title="103"></a>
<a class="sourceLine" id="cb59-104" title="104">    trial.report(avg_val_loss, epoch)</a>
<a class="sourceLine" id="cb59-105" title="105"></a>
<a class="sourceLine" id="cb59-106" title="106">    <span class="co"># Handle pruning based on the intermediate value.</span></a>
<a class="sourceLine" id="cb59-107" title="107">    <span class="cf">if</span> trial.should_prune():</a>
<a class="sourceLine" id="cb59-108" title="108">        <span class="cf">raise</span> optuna.exceptions.TrialPruned()</a>
<a class="sourceLine" id="cb59-109" title="109"></a>
<a class="sourceLine" id="cb59-110" title="110">    <span class="cf">return</span> avg_val_loss</a>
<a class="sourceLine" id="cb59-111" title="111"></a>
<a class="sourceLine" id="cb59-112" title="112"></a>
<a class="sourceLine" id="cb59-113" title="113"></a>
<a class="sourceLine" id="cb59-114" title="114">study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">&quot;minimize&quot;</span>,</a>
<a class="sourceLine" id="cb59-115" title="115">                            pruner<span class="op">=</span>optuna.pruners.HyperbandPruner(min_resource<span class="op">=</span><span class="dv">1</span>,</a>
<a class="sourceLine" id="cb59-116" title="116">                                                                  max_resource<span class="op">=</span><span class="dv">5</span>,</a>
<a class="sourceLine" id="cb59-117" title="117">                                                                  reduction_factor<span class="op">=</span><span class="dv">3</span>,</a>
<a class="sourceLine" id="cb59-118" title="118">                                                                  ))</a>
<a class="sourceLine" id="cb59-119" title="119">study.optimize(objective, n_trials<span class="op">=</span><span class="dv">35</span>)</a>
<a class="sourceLine" id="cb59-120" title="120"></a>
<a class="sourceLine" id="cb59-121" title="121"></a>
<a class="sourceLine" id="cb59-122" title="122">pruned_trials <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> study.trials <span class="cf">if</span> t.state <span class="op">==</span> optuna.trial.TrialState.PRUNED]</a>
<a class="sourceLine" id="cb59-123" title="123">complete_trials <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> study.trials <span class="cf">if</span> t.state <span class="op">==</span> optuna.trial.TrialState.COMPLETE]</a>
<a class="sourceLine" id="cb59-124" title="124"></a>
<a class="sourceLine" id="cb59-125" title="125"><span class="bu">print</span>(<span class="st">&quot;Study statistics: &quot;</span>)</a>
<a class="sourceLine" id="cb59-126" title="126"><span class="bu">print</span>(<span class="st">&quot;  Number of finished trials: &quot;</span>, <span class="bu">len</span>(study.trials))</a>
<a class="sourceLine" id="cb59-127" title="127"><span class="bu">print</span>(<span class="st">&quot;  Number of pruned trials: &quot;</span>, <span class="bu">len</span>(pruned_trials))</a>
<a class="sourceLine" id="cb59-128" title="128"><span class="bu">print</span>(<span class="st">&quot;  Number of complete trials: &quot;</span>, <span class="bu">len</span>(complete_trials))</a>
<a class="sourceLine" id="cb59-129" title="129"></a>
<a class="sourceLine" id="cb59-130" title="130"><span class="bu">print</span>(<span class="st">&quot;Best trial:&quot;</span>)</a>
<a class="sourceLine" id="cb59-131" title="131">trial <span class="op">=</span> study.best_trial</a>
<a class="sourceLine" id="cb59-132" title="132"></a>
<a class="sourceLine" id="cb59-133" title="133"><span class="bu">print</span>(<span class="st">&quot;  Value: &quot;</span>, trial.value)</a>
<a class="sourceLine" id="cb59-134" title="134"></a>
<a class="sourceLine" id="cb59-135" title="135"><span class="bu">print</span>(<span class="st">&quot;  Params: &quot;</span>)</a>
<a class="sourceLine" id="cb59-136" title="136"><span class="cf">for</span> key, value <span class="kw">in</span> trial.params.items():</a>
<a class="sourceLine" id="cb59-137" title="137">    <span class="bu">print</span>(<span class="st">&quot;    </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(key, value))</a></code></pre></div>
</div>
<div id="sources" class="section level1">
<h1><span class="header-section-number">6</span> Sources</h1>
<ul>
<li><p>Pennington, Jeffrey, Richard Socher, and Christopher D. Manning. “Glove: Global vectors for word representation.” In Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP), pp. 1532-1543. 2014. GloVe <a href="https://nlp.stanford.edu/projects/glove/" class="uri">https://nlp.stanford.edu/projects/glove/</a></p></li>
<li><p>Kim, Yoon. “Convolutional neural networks for sentence classification.” arXiv preprint arXiv:1408.5882 (2014).</p></li>
</ul>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
